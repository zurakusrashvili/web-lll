<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright Â© 2012-2022 ZeyOS GmbH & Co. KG. All rights reserved. -->
<ixmldoc>
	<definitions>
		<terminology>
			<term name="Element">Simple XML element</term>
			<term name="Structure">Compound XML structure containing one or more elements</term>
			<term name="Operation">Semantic definition of an element</term>
			<term name="Construct">Semantic definition of a structure</term>
			<term name="Statement">Executable instance of an operation or construct</term>
			<term name="Code">Series of statements</term>
		</terminology>

		<occurrences>
			<occurrence name="single">Element may appear once at most</occurrence>
			<occurrence name="multiple">Element may appear any number of times including not at all</occurrence>
		</occurrences>

		<inputtypes>
			<type name="var">String referencing a variable ('name') or an array item with a specific key ('name[key]', 'name.key') (unnecessary whitespace characters are automatically stripped)</type>
			<type name="bool">Applicable if set and not empty</type>
			<type name="int">Arithmetic expression cast to an integer number</type>
			<type name="float">Arithmetic expression cast to a floating point number</type>
			<type name="date">Arithmetic expression cast to an integer number and interpreted as a Unix timestamp</type>
			<type name="string">Arbitrary byte sequence or series of Unicode (UTF-8) characters</type>
			<type name="regexp">String interpreted as a Perl-compatible regular expression pattern enclosed in delimiters ('/[a-z]+/i')</type>
			<type name="type">Meta type (case-insensitive)</type>
			<type name="ixml">Arbitrary code</type>
		</inputtypes>

		<resulttypes>
			<type name="null">NULL</type>
			<type name="bool">Boolean</type>
			<type name="int">Integer number</type>
			<type name="float">Floating point number</type>
			<type name="string">String (arbitrary byte sequence)</type>
			<type name="array">Array (collection of items in an ordered map that associates keys to values)</type>
			<type name="function">Function (closed subroutine)</type>
			<type name="macro">Macro (open subroutine)</type>
			<type name="class">Class (array prototype)</type>
		</resulttypes>

		<predicates>
			<predicate name="no-result-propagation">Result is not propagated to paternal statement</predicate>
		</predicates>
	</definitions>

	<language>
		<description title="iXML envelope">
			<![CDATA[
				<?xml version="1.0" encoding="UTF-8"?>
				<!DOCTYPE ixml SYSTEM "https://developers.zeyos.com/schema/ixml.dtd">
				<ixml
					xmlns="https://developers.zeyos.com/schema/ixml"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="https://developers.zeyos.com/schema/ixml https://developers.zeyos.com/schema/ixml.xsd">

				<!-- Code -->

				</ixml>
			]]>
		</description>

		<description title="Variables">
			<![CDATA[
				The name of a variable is a placeholder for its value, the data it holds. Referencing its value is called variable substitution. Variables that are referenced inside an expression are expanded to their respective values. For that purpose variables are represented by a dollar sign ('$') followed by the name of the variable. The next punctuation character implicitly ends the variable name even though it may explicitly be concluded by a trailing dollar sign ('$'). A dollar sign ('$') is passed unchanged if not followed by an alphanumeric character or underscore. Two adjacent dollar signs ('$$') are substituted with one single dollar sign ('$') as an escape syntax. The variable name is case-sensitive and consists of alphanumeric characters and underscores only.
				Variables typically have a single local scope and are therefore only visible within the immediate context, unless they have been specifically declared as global variables in which case they are given global scope and are then independent of the context within which they are defined. Closures may be used to establish a referencing environment for free function variables. Those variables are explicitly bound to corresponding variables from the immediate context within which a function is defined, thereby directly referencing non-local variables from the parent scope outside of the inherent context of that function. The order of visibility precedence from highest to lowest is: special local variables (e.g. 'this', 'return', 'arguments'), free function variables, regular local variables (parameters), global variables.
				Primitive non-composite variables are always assigned by value while complex variables are always assigned by reference. Assignment by reference may cause circular references. Complex data structures with circular references are considered bad practice as they generally entail memory management drawbacks and possibly raise maximum stack depth exceptions when operated on.
				Using a variable before assigning a value to it may cause problems. It is nevertheless possible to perform operations on an uninitialized variable as it then defaults to the neutral literal of the accordant input type.

				<set var="name">iXML</set>
				<output>My name is $name!</output>
				<!-- My name is iXML! -->

				A special shortcut syntax may be used for referencing array items directly by specifing the corresponding key, either enclosed in square brackets ('[]') or appended with a dot ('.').

				<set var="names[bg]">Bill Gates</set>
				<set var="names[sj]">Steve Jobs</set>
				<output>$names[bg] and $names[sj] are competitors!</output>
				<!-- Bill Gates and Steve Jobs are competitors! -->

				Within square brackets (array notation) a key is not interpreted as a literal but as an expression, resulting in further variable substitution. Although empty brackets will simply be interpreted as empty key literals in case of substitution or when used for getting or unsetting in general, they will implicitly generate a consecutive numeric key when used for setting.

				<set var="names[bg]">Bill Gates</set>
				<set var="names[sj]">Steve Jobs</set>
				<set var="key1">bg</set>
				<set var="key2">sj</set>
				<output>$names[$key1] and $names[$key2] are competitors!</output>
				<!-- Bill Gates and Steve Jobs are competitors! -->

				A key that is appended with a dot (object notation) is always interpreted as a literal. Although keys in general may consist of any characters whatsoever, they may consist of alphanumeric characters and underscores only when accessed with the object notation (dot syntax). This specific restriction does not apply to the array notation (square bracket syntax).

				<set var="names.bg">Bill Gates</set>
				<set var="names.sj">Steve Jobs</set>
				<output>$names.bg and $names.sj are competitors!</output>
				<!-- Bill Gates and Steve Jobs are competitors! -->

				Several keys may also be strung together to form a key chain of arbitrary length, which allows multidimensional arrays to be accessed directly, whereby the array notation (square bracket syntax) and the object notation (dot syntax) may be mixed.

				<set var="names.microsoft[bg]">Bill Gates</set>
				<set var="names[apple].sj">Steve Jobs</set>
				<output>$names[microsoft].bg and $names.apple[sj] are competitors!</output>
				<!-- Bill Gates and Steve Jobs are competitors! -->

				References of array items may also be deeply nested within the array notation (square bracket syntax) or other substitution mechanisms.

				<set var="names.bg">Bill Gates</set>
				<set var="names[sj]">Steve Jobs</set>
				<set var="keys[bill_gates]">bg</set>
				<set var="keys.steve_jobs">sj</set>
				<output>$names[$keys.bill_gates] and $names[$keys[steve_jobs]] are competitors!</output>
				<!-- Bill Gates and Steve Jobs are competitors! -->

				A special shortcut syntax may be used for substitution of embedded functional expressions pertaining to a variable that references a function (parenthesis syntax). Functional expressions that are embedded inside another expression are replaced by their result. For that purpose functional expressions are represented by a leading variable reference followed by a single argument put into parentheses ('()').

				<function var="lcase">
					<tolower var="return">$return</tolower>
				</function>

				<set var="name">iXML</set>
				<output>My name is $lcase($name)!</output>
				<!-- My name is ixml! -->

				Functional expressions in parenthesis syntax may also be deeply nested within other substitution mechanisms.

				The data type of a variable is determined by the context in which the variable is used and defaults to the neutral literal of the accordant input type.

				iXML recognizes the following data types for variables:

				Type     Neutral Literal Description
				-----------------------------------------------------------------------------------------------------
				null     NULL            NULL
				bool     FALSE           Boolean (true or false)
				int      0               Integer number
				float    0.0             Floating point number
				string   ''              String (arbitrary byte sequence)
				array    -               Array (collection of items in an ordered map that associates keys to values)
				function -               Function (closed subroutine)
				macro    -               Macro (open subroutine)
				class    -               Class (array prototype)

				An undeclared variable is undefined and therefore has neither type nor value. The NULL value however indicates a variable that is defined but does not hold any data. It can be thought of as uninitialized, invalid or empty. NULL is not equivalent to the ASCII NUL byte ('\0') and, although comparable, it is semantically different from an empty string.

				The extended classification includes the following additional pseudo-types that generalize semantically related intrinsic data types:

				Pseudo-Type Intrinsic Types            Description
				----------------------------------------------------------------------------------------
				number      int/float                  Integer or floating point number
				numeric     int/float/string           Number or string representation thereof
				scalar      bool/int/float/string      All primitive non-composite types other than NULL
				subroutine  function/macro             Subroutine
				complex     array/function/macro/class All complex types

				Value       Types                       TYPEOF      IF='' IF!='' IF='0' CAST(bool) CAST(int) CAST(float) CAST(string)
				-------------------------------------------------------------------------------------------------------------------------
				<undefined> -                           'undefined' true  false  false  false      0         0           ''
				NULL        null                        'null'      true  false  false  false      0         0           ''
				TRUE        bool/scalar                 'bool'      false true   false  true       1         1           '1'
				FALSE       bool/scalar                 'bool'      true  false  false  false      0         0           ''
				0           int/number/numeric/scalar   'int'       false true   true   false      0         0           '0'
				123         int/number/numeric/scalar   'int'       false true   false  true       123       123         '123'
				0.0         float/number/numeric/scalar 'float'     false true   true   false      0         0           '0'
				123.123     float/number/numeric/scalar 'float'     false true   false  true       123       123.123     '123.123'
				'0'         string/numeric/scalar       'string'    false true   true   false      0         0           '0'
				'123'       string/numeric/scalar       'string'    false true   false  true       123       123         '123'
				''          string/scalar               'string'    true  false  false  false      0         0           ''
				'abc'       string/scalar               'string'    false true   false  true       0         0           'abc'
				<array>     array/complex               'array'     false true   false  true       0         0           '[array#123]'
				<function>  function/subroutine/complex 'function'  false true   false  true       0         0           '[function#123]'
				<macro>     macro/subroutine/complex    'macro'     false true   false  true       0         0           '[macro#123]'
				<class>     class/complex               'class'     false true   false  true       0         0           '[class#123]'
			]]>
		</description>

		<description title="Arithmetic expressions">
			<![CDATA[
				An arithmetic expression is a placeholder for its result. Whenever a number is explicitly expected, the corresponding expression is automatically evaluated arithmetically. Its result is then implicitly cast to the appropriate input type.
				All C-like arithmetic and bitwise operators as well as their respective precedences are applicable to arithmetic expressions. Integer numbers can be specified in decimal (base 10), hexadecimal (base 16, '0x...'), octal (base 8, '0...') or binary (base 2, '0b...') notation while floating point numbers can be specified in decimal (base 10) or scientific E notation.

				<math:abs var="number">(0x12 - 19.5) * $number</math:abs>

				A special shortcut syntax may be used for substitution of embedded arithmetic expressions that are independent of the superordinate data type (parenthesis syntax). Arithmetic expressions that are embedded inside another expression are replaced by their result. For that purpose arithmetic expressions are represented by a leading dollar sign ('$') and put into parentheses ('()').

				<set var="birthyear">1950</set>
				<output>This person is $(2012 - $birthyear) years old!</output>
				<!-- This person is 62 years old! -->

				Arithmetic expressions in parenthesis syntax may also be deeply nested within other substitution mechanisms.

				<array var="names">
					<item>Bill Gates</item>
					<item>Steve Jobs</item>
				</array>

				<output>$names[0] and $names[$(0 + 1)] are competitors!</output>
				<!-- Bill Gates and Steve Jobs are competitors! -->
			]]>
		</description>

		<description title="Result propagation">
			<![CDATA[
				Any CDATA value of a statement may be replaced with the result of an embedded statement, unless it is explicitly precluded. An incompatible result type is thereby implicitly cast to the appropriate input type.

				<set var="number">$(15 + (7.5 * 2 - 3))</set>
				<output>$number</output>
				<!-- 27 -->

				<output>
					<set>$(15 + (7.5 * 2 - 3))</set>
				</output>
				<!-- 27 -->

				At the same time the result may still be stored in a result variable if specified.

				<output>
					<set var="number">$(15 + (7.5 * 2 - 3))</set>
				</output>

				<output>,$number</output>

				<!-- 27,27 -->

				If code is embedded, the last scalar result is then used for propagation.

				<output>
					<set var="number">10</set>
					<set>$($number + 100)</set>
					<set>$($number + 5)</set>
				</output>
				<!-- 15 -->

				The embedded code may also be deeply nested. Results of IF, IS and SWITCH are then propagated to the topmost statement.

				<set var="born">1945</set>

				<output>
					<if value1="$born" func="&lt;" value2="1950">
						<set>This person is very old!</set>

						<else>
							<set>$(2012 - $born)</set>
						</else>
					</if>
				</output>

				<!-- This person is very old! -->

				Any CDATA values that are used alongside embedded code are discarded.

				<output>
					<set>$(15 + (7.5 * 2 - 3))</set>
					471
				</output>
				<!-- 27 -->

				Result propagation is also applicable to user-defined functions.

				<function var="getName">
					<set var="return">iXML</set>
				</function>

				<output>
					<call func="getName"/>
				</output>

				<!-- iXML -->
			]]>
		</description>
	</language>

	<namespace name="ctrl" title="Control constructs">
		<command name="if" title="Conditional value execution">
			<attributes>
				<attribute name="value1" type="string" title="Value to compare from"/>
				<attribute name="value2" type="string|regexp" title="Value to compare to"/>

				<attribute name="func" type="string" default="=" title="Comparison function">
					<value title="Equals">=</value>
					<value title="Equals, case-insensitive">=*</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Not equals, case-insensitive">!=*</value>
					<value title="Not equals, case-insensitive">&lt;&gt;*</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
					<value title="Contains">_</value>
					<value title="Contains, case-insensitive">_*</value>
					<value title="Not contains">!_</value>
					<value title="Not contains, case-insensitive">!_*</value>
					<value title="Starts with">^</value>
					<value title="Starts with, case-insensitive">^*</value>
					<value title="Not starts with">!^</value>
					<value title="Not starts with, case-insensitive">!^*</value>
					<value title="Ends with">$</value>
					<value title="Ends with, case-insensitive">$*</value>
					<value title="Not ends with">!$</value>
					<value title="Not ends with, case-insensitive">!$*</value>
					<value title="Matches regular expression">~</value>
					<value title="Not matches regular expression">!~</value>
				</attribute>
			</attributes>

			<children>
				<child name="elseif" title="Elsewise conditional value execution" occurrence="multiple">
					<attributes>
						<attribute name="value1" type="string" title="Value to compare from"/>
						<attribute name="value2" type="string|regexp" title="Value to compare to"/>

						<attribute name="func" type="string" default="=" title="Comparison function">
							<value title="Equals">=</value>
							<value title="Equals, case-insensitive">=*</value>
							<value title="Not equals">!=</value>
							<value title="Not equals">&lt;&gt;</value>
							<value title="Not equals, case-insensitive">!=*</value>
							<value title="Not equals, case-insensitive">&lt;&gt;*</value>
							<value title="Less than">&lt;</value>
							<value title="Less than or equal to">&lt;=</value>
							<value title="Greater than">&gt;</value>
							<value title="Greater than or equal to">&gt;=</value>
							<value title="Contains">_</value>
							<value title="Contains, case-insensitive">_*</value>
							<value title="Not contains">!_</value>
							<value title="Not contains, case-insensitive">!_*</value>
							<value title="Starts with">^</value>
							<value title="Starts with, case-insensitive">^*</value>
							<value title="Not starts with">!^</value>
							<value title="Not starts with, case-insensitive">!^*</value>
							<value title="Ends with">$</value>
							<value title="Ends with, case-insensitive">$*</value>
							<value title="Not ends with">!$</value>
							<value title="Not ends with, case-insensitive">!$*</value>
							<value title="Matches regular expression">~</value>
							<value title="Not matches regular expression">!~</value>
						</attribute>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="elseis" title="Elsewise conditional type execution" occurrence="multiple">
					<attributes>
						<attribute name="var" type="var" title="Variable name"/>

						<attribute name="type" type="type" default="valid" title="Type">
							<value title="Is valid (defined and not NULL nor FALSE)">valid</value>
							<value title="Is not valid">non-valid</value>
							<value title="Is empty (non-valid, numeric zero, empty string or empty array)">empty</value>
							<value title="Is not empty">non-empty</value>
							<value title="Is defined">defined</value>
							<value title="Is undefined">undefined</value>
							<value title="Is NULL">null</value>
							<value title="Is not NULL">non-null</value>
							<value title="Is TRUE">true</value>
							<value title="Is not TRUE">non-true</value>
							<value title="Is FALSE">false</value>
							<value title="Is not FALSE">non-false</value>
							<value title="Is a boolean">bool</value>
							<value title="Is not a boolean">non-bool</value>
							<value title="Is an integer number">int</value>
							<value title="Is not an integer number">non-int</value>
							<value title="Is a floating point number">float</value>
							<value title="Is not a floating point number">non-float</value>
							<value title="Is a string">string</value>
							<value title="Is not a string">non-string</value>
							<value title="Is an array">array</value>
							<value title="Is not an array">non-array</value>
							<value title="Is a function">function</value>
							<value title="Is not a function">non-function</value>
							<value title="Is a macro">macro</value>
							<value title="Is not a macro">non-macro</value>
							<value title="Is a class">class</value>
							<value title="Is not a class">non-class</value>
							<value title="Is a number">number</value>
							<value title="Is not a number">non-number</value>
							<value title="Is numeric">numeric</value>
							<value title="Is non-numeric">non-numeric</value>
							<value title="Is scalar">scalar</value>
							<value title="Is non-scalar">non-scalar</value>
							<value title="Is a subroutine">subroutine</value>
							<value title="Is not a subroutine">non-subroutine</value>
							<value title="Is a complex type">complex</value>
							<value title="Is not a complex type">non-complex</value>
							<value title="Is not a number (NaN)">nan</value>
							<value title="Is positive or negative infinite (INF)">infinite</value>
						</attribute>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="else" title="Elsewise execution" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<content type="ixml"/>

			<description>The IF construct is a control flow structure that allows for conditional execution of code dependent on two values.</description>
			<description>If the condition is true, the embedded code is executed. Otherwise, a series of embedded ELSEIF and ELSEIS statements is tested one by one. Only the first ELSEIF or ELSEIS statement that is found to be true will be executed. If none of the conditions are true, the embedded ELSE statement will be executed instead.</description>

			<attention>Comparison of numeric values is always performed numerically regardless of the intrinsic data types.</attention>
			<attention>Regular expression matches regard 'value1' as the subject and 'value2' as the pattern.</attention>
			<attention>IF will propagate results into the context of its paternal statement.</attention>

			<example title="Basic comparison">
				<![CDATA[
					<set var="name">iXML</set>

					<if value1="$name" func="=" value2="iXML">
						<output>My name is iXML!</output>

						<else>
							<output>My name is not iXML!</output>
						</else>
					</if>

					<!-- My name is iXML! -->
				]]>
			</example>

			<example title="Multiple comparison">
				<![CDATA[
					<set var="name">Steve Jobs</set>

					<if value1="$name" func="=" value2="Bill Gates">
						<output>My name is Bill Gates!</output>

						<elseif value1="$name" func="=" value2="Steve Jobs">
							<output>My name is Steve Jobs!</output>
						</elseif>

						<else>
							<output>My name is not Bill Gates nor Steve Jobs!</output>
						</else>
					</if>

					<!-- My name is Steve Jobs! -->
				]]>
			</example>

			<example title="Regular expression match">
				<![CDATA[
					<set var="name">iXML</set>

					<if value1="$name" func="~" value2="/^I/i">
						<output>My name starts with an I!</output>
					</if>

					<!-- My name starts with an I! -->
				]]>
			</example>
		</command>

		<command name="is" title="Conditional type execution">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>

				<attribute name="type" type="type" default="valid" title="Type">
					<value title="Is valid (defined and not NULL nor FALSE)">valid</value>
					<value title="Is not valid">non-valid</value>
					<value title="Is empty (non-valid, numeric zero, empty string or empty array)">empty</value>
					<value title="Is not empty">non-empty</value>
					<value title="Is defined">defined</value>
					<value title="Is undefined">undefined</value>
					<value title="Is NULL">null</value>
					<value title="Is not NULL">non-null</value>
					<value title="Is TRUE">true</value>
					<value title="Is not TRUE">non-true</value>
					<value title="Is FALSE">false</value>
					<value title="Is not FALSE">non-false</value>
					<value title="Is a boolean">bool</value>
					<value title="Is not a boolean">non-bool</value>
					<value title="Is an integer number">int</value>
					<value title="Is not an integer number">non-int</value>
					<value title="Is a floating point number">float</value>
					<value title="Is not a floating point number">non-float</value>
					<value title="Is a string">string</value>
					<value title="Is not a string">non-string</value>
					<value title="Is an array">array</value>
					<value title="Is not an array">non-array</value>
					<value title="Is a function">function</value>
					<value title="Is not a function">non-function</value>
					<value title="Is a macro">macro</value>
					<value title="Is not a macro">non-macro</value>
					<value title="Is a class">class</value>
					<value title="Is not a class">non-class</value>
					<value title="Is a number">number</value>
					<value title="Is not a number">non-number</value>
					<value title="Is numeric">numeric</value>
					<value title="Is non-numeric">non-numeric</value>
					<value title="Is scalar">scalar</value>
					<value title="Is non-scalar">non-scalar</value>
					<value title="Is a subroutine">subroutine</value>
					<value title="Is not a subroutine">non-subroutine</value>
					<value title="Is a complex type">complex</value>
					<value title="Is not a complex type">non-complex</value>
					<value title="Is not a number (NaN)">nan</value>
					<value title="Is positive or negative infinite (INF)">infinite</value>
				</attribute>
			</attributes>

			<children>
				<child name="elseif" title="Elsewise conditional value execution" occurrence="multiple">
					<attributes>
						<attribute name="value1" type="string" title="Value to compare from"/>
						<attribute name="value2" type="string|regexp" title="Value to compare to"/>

						<attribute name="func" type="string" default="=" title="Comparison function">
							<value title="Equals">=</value>
							<value title="Equals, case-insensitive">=*</value>
							<value title="Not equals">!=</value>
							<value title="Not equals">&lt;&gt;</value>
							<value title="Not equals, case-insensitive">!=*</value>
							<value title="Not equals, case-insensitive">&lt;&gt;*</value>
							<value title="Less than">&lt;</value>
							<value title="Less than or equal to">&lt;=</value>
							<value title="Greater than">&gt;</value>
							<value title="Greater than or equal to">&gt;=</value>
							<value title="Contains">_</value>
							<value title="Contains, case-insensitive">_*</value>
							<value title="Not contains">!_</value>
							<value title="Not contains, case-insensitive">!_*</value>
							<value title="Starts with">^</value>
							<value title="Starts with, case-insensitive">^*</value>
							<value title="Not starts with">!^</value>
							<value title="Not starts with, case-insensitive">!^*</value>
							<value title="Ends with">$</value>
							<value title="Ends with, case-insensitive">$*</value>
							<value title="Not ends with">!$</value>
							<value title="Not ends with, case-insensitive">!$*</value>
							<value title="Matches regular expression">~</value>
							<value title="Not matches regular expression">!~</value>
						</attribute>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="elseis" title="Elsewise conditional type execution" occurrence="multiple">
					<attributes>
						<attribute name="var" type="var" title="Variable name"/>

						<attribute name="type" type="type" default="valid" title="Type">
							<value title="Is valid (defined and not NULL nor FALSE)">valid</value>
							<value title="Is not valid">non-valid</value>
							<value title="Is empty (non-valid, numeric zero, empty string or empty array)">empty</value>
							<value title="Is not empty">non-empty</value>
							<value title="Is defined">defined</value>
							<value title="Is undefined">undefined</value>
							<value title="Is NULL">null</value>
							<value title="Is not NULL">non-null</value>
							<value title="Is TRUE">true</value>
							<value title="Is not TRUE">non-true</value>
							<value title="Is FALSE">false</value>
							<value title="Is not FALSE">non-false</value>
							<value title="Is a boolean">bool</value>
							<value title="Is not a boolean">non-bool</value>
							<value title="Is an integer number">int</value>
							<value title="Is not an integer number">non-int</value>
							<value title="Is a floating point number">float</value>
							<value title="Is not a floating point number">non-float</value>
							<value title="Is a string">string</value>
							<value title="Is not a string">non-string</value>
							<value title="Is an array">array</value>
							<value title="Is not an array">non-array</value>
							<value title="Is a function">function</value>
							<value title="Is not a function">non-function</value>
							<value title="Is a class">class</value>
							<value title="Is not a class">non-class</value>
							<value title="Is a number">number</value>
							<value title="Is not a number">non-number</value>
							<value title="Is numeric">numeric</value>
							<value title="Is non-numeric">non-numeric</value>
							<value title="Is scalar">scalar</value>
							<value title="Is non-scalar">non-scalar</value>
							<value title="Is a subroutine">subroutine</value>
							<value title="Is not a subroutine">non-subroutine</value>
							<value title="Is a complex type">complex</value>
							<value title="Is not a complex type">non-complex</value>
							<value title="Is not a number (NaN)">nan</value>
							<value title="Is positive or negative infinite (INF)">infinite</value>
						</attribute>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="else" title="Elsewise execution" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<description>The IS construct is a control flow structure that allows for conditional execution of code dependent on the data type of a variable.</description>
			<description>If the condition is true, the embedded code is executed. Otherwise, a series of embedded ELSEIF and ELSEIS statements is tested one by one. Only the first ELSEIF or ELSEIS statement that is found to be true will be executed. If none of the conditions are true, the embedded ELSE statement will be executed instead.</description>

			<attention>IS will propagate results into the context of its paternal statement.</attention>

			<example>
				<![CDATA[
					<set var="name">iXML</set>

					<is var="name" type="string">
						<output>My name is a string!</output>
					</is>

					<!-- My name is a string! -->
				]]>
			</example>
		</command>

		<command name="switch" title="Selective execution">
			<attributes>
				<attribute name="value" type="string" title="Value to compare from"/>
			</attributes>

			<children>
				<child name="case" title="Branch execution" occurrence="multiple">
					<attributes>
						<attribute name="value" type="string" title="Value to compare to"/>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="default" title="Default execution" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<description>The SWITCH construct is a control flow structure that allows for selective execution of code controlled via a multiway branch. It can be thought of as a series of IF constructs, each with the same value to compare from.</description>
			<description>If the value of a SWITCH statement equals the value of an embedded CASE statement, the control flow continues with the execution of that CASE statement. Otherwise, the control flow continues with the execution of the embedded DEFAULT statement.</description>

			<attention>Comparison of numeric values is always performed numerically regardless of the intrinsic data types.</attention>
			<attention>It is in some cases desirable, for a branch to intentionally fall through to the next branch, thereby creating a cascading execution stack. For that prupose the NEXT operation may be used to skip the rest of the current CASE statement and continue with the execution of the next consecutive CASE statement inside the same paternal SWITCH statement. Also, the BREAK operation may be used to break-off the execution of the current CASE or DEFAULT statement and continue with the execution outside the paternal SWITCH statement.</attention>
			<attention>SWITCH will propagate results into the context of its paternal statement.</attention>

			<example title="Basic branch">
				<![CDATA[
					<set var="lastname">Gates</set>

					<switch value="$lastname">
						<case value="Gates">
							<output>My name might be Bill Gates!</output>
						</case>

						<case value="Jobs">
							<output>My name might be Steve Jobs!</output>
						</case>

						<default>
							<output>My name is not Bill Gates nor Steve Jobs!</output>
						</default>
					</switch>

					<!-- My name might be Bill Gates! -->
				]]>
			</example>

			<example title="Fall-through branch">
				<![CDATA[
					<set var="firstname">Steve</set>
					<set var="lastname">Gates</set>

					<switch value="$lastname">
						<case value="Gates">
							<if value1="$firstname" func="=" value2="Steve">
								<next/>
							</if>

							<output>My name might be Bill Gates!</output>
						</case>

						<case value="Jobs">
							<output>My name might be Steve Jobs!</output>
						</case>
					</switch>

					<!-- My name might be Steve Jobs! -->
				]]>
			</example>
		</command>

		<command name="while" title="While loop">
			<attributes>
				<attribute name="value1" type="string" title="Value to compare from"/>
				<attribute name="value2" type="string|regexp" title="Value to compare to"/>

				<attribute name="func" type="string" default="=" title="Comparison function">
					<value title="Equals">=</value>
					<value title="Equals, case-insensitive">=*</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Not equals, case-insensitive">!=*</value>
					<value title="Not equals, case-insensitive">&lt;&gt;*</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
					<value title="Contains">_</value>
					<value title="Contains, case-insensitive">_*</value>
					<value title="Not contains">!_</value>
					<value title="Not contains, case-insensitive">!_*</value>
					<value title="Starts with">^</value>
					<value title="Starts with, case-insensitive">^*</value>
					<value title="Not starts with">!^</value>
					<value title="Not starts with, case-insensitive">!^*</value>
					<value title="Ends with">$</value>
					<value title="Ends with, case-insensitive">$*</value>
					<value title="Not ends with">!$</value>
					<value title="Not ends with, case-insensitive">!$*</value>
					<value title="Matches regular expression">~</value>
					<value title="Not matches regular expression">!~</value>
				</attribute>
			</attributes>

			<children>
				<child name="else" title="Elsewise execution" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<content type="ixml"/>

			<description>The WHILE construct is a control flow structure that allows code to be executed repeatedly based on a condition. It can be thought of as a repeating IF construct that is being re-evaluated before each loop iteration.</description>
			<description>While the condition is true, the embedded code is executed. Otherwise, the execution continues outside the loop.</description>

			<attention>Comparison of numeric values is always performed numerically regardless of the intrinsic data types.</attention>
			<attention>Regular expression matches regard 'value1' as the subject and 'value2' as the pattern.</attention>
			<attention>It is possible, and in some cases desirable, for the condition to always evaluate to true, thereby creating an infinite loop. When such a loop is created intentionally, there is the BREAK operation that controls termination of the loop.</attention>
			<attention>The BREAK operation may be used to break-off the execution of the current loop iteration, thereby implicitly terminating the loop. Also, the NEXT operation may be used to skip the rest of the current loop iteration and continue with the condition evaluation at the beginning of the next loop iteration.</attention>

			<example title="Basic comparison">
				<![CDATA[
					<set var="count">0</set>

					<while value1="$count" func="&lt;" value2="10">
						<output>$count</output>
						<math:inc var="count"/>
					</while>

					<!-- 0123456789 -->
				]]>
			</example>

			<example title="Indirect loop termination">
				<![CDATA[
					<set var="count">0</set>

					<while>
						<output>$count</output>
						<math:inc var="count"/>

						<if value1="$count" func="=" value2="10">
							<break/>
						</if>
					</while>

					<!-- 0123456789 -->
				]]>
			</example>

			<example title="Continuation with next iteration">
				<![CDATA[
					<set var="count">0</set>

					<while value1="$count" func="&lt;" value2="9">
						<math:inc var="count"/>

						<if value1="$count" func="=" value2="5">
							<next/>
						</if>

						<output>$count</output>
					</while>

					<!-- 12346789 -->
				]]>
			</example>
		</command>

		<command name="for" title="For loop">
			<attributes>
				<attribute name="var" type="var" title="Variable name for loop counter"/>
				<attribute name="from" type="int" title="From"/>
				<attribute name="to" type="int" title="To"/>
				<attribute name="step" type="int" default="1" title="Step"/>
			</attributes>

			<content type="ixml"/>

			<description>The FOR construct is a control flow structure for arithmetic progression, enumerating values of a given numeric range.</description>
			<description>On each loop iteration, the embedded code is executed with the loop counter assigned to 'var'.</description>

			<attention>If the step is less than one, the loop will not start at all.</attention>
			<attention>The BREAK operation may be used to break-off the execution of the current loop iteration, thereby implicitly terminating the loop. Also, the NEXT operation may be used to skip the rest of the current loop iteration and continue with the execution of the next loop iteration.</attention>

			<example title="Incremental enumeration">
				<![CDATA[
					<for var="count" from="6" to="10" step="2">
						<output>$count&n;</output>
					</for>

					<!--
					6
					8
					10
					-->
				]]>
			</example>

			<example title="Decremental enumeration">
				<![CDATA[
					<for var="count" from="10" to="6" step="2">
						<output>$count&n;</output>
					</for>

					<!--
					10
					8
					6
					-->
				]]>
			</example>
		</command>

		<command name="foreach" title="For each loop">
			<attributes>
				<attribute name="var" type="var" title="Source variable name"/>
				<attribute name="var_key" type="var" title="Variable name for key"/>
				<attribute name="var_value" type="var" title="Variable name for value"/>
			</attributes>

			<children>
				<child name="else" title="Elsewise execution" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<content type="ixml"/>

			<description>The FOREACH construct is a control flow structure for traversing items in a collection by iterating over an array, populating the associated key and value pairs for each item.</description>
			<description>On each loop iteration, the embedded code is executed with the key of the current item assigned to 'var_key' and the value of the current item assigned to 'var_value'.</description>

			<attention>The BREAK operation may be used to break-off the execution of the current loop iteration, thereby implicitly terminating the loop. Also, the NEXT operation may be used to skip the rest of the current loop iteration and continue with the execution of the next loop iteration.</attention>

			<example title="Iterating over an array">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<output>$name&n;</output>
					</foreach>

					<!--
					Bill Gates
					Steve Jobs
					-->
				]]>
			</example>

			<example title="Dynamically altering an array">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_key="key" var_value="name">
						<if value1="$name" func="=" value2="Bill Gates">
							<set var="names[$key]">William Henry Gates III</set>
						</if>
					</foreach>

					<output>
						<array:join var="names" delimiter=", "/>
					</output>

					<!-- William Henry Gates III, Steve Jobs -->
				]]>
			</example>

			<example title="Dynamically altering a multidimensional array">
				<![CDATA[
					<array var="names">
						<array>
							<item key="firstname">Bill</item>
							<item key="lastname">Gates</item>
						</array>
						<array>
							<item key="firstname">Steve</item>
							<item key="lastname">Jobs</item>
						</array>
					</array>

					<foreach var="names" var_value="name">
						<if value1="$name.lastname" func="=" value2="Gates">
							<set var="name.fullname">William Henry Gates III</set>
						</if>
					</foreach>

					<output>$names[0].fullname</output>

					<!-- William Henry Gates III -->
				]]>
			</example>

			<example title="Indirect loop termination">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<output>$name</output>

						<if value1="$name" func="=" value2="Bill Gates">
							<break/>
						</if>
					</foreach>

					<!-- Bill Gates -->
				]]>
			</example>

			<example title="Continuation with next iteration">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<if value1="$name" func="=" value2="Bill Gates">
							<next/>
						</if>

						<output>$name</output>
					</foreach>

					<!-- Steve Jobs -->
				]]>
			</example>
		</command>

		<command name="exit" title="Exit">
			<content type="string" title="Value"/>

			<description>EXIT irreversibly halts the execution completely after a final output.</description>
		</command>

		<command name="return" title="Return">
			<description>RETURN returns to the original control flow of the invoking control statement, thereby passing back the special local variable 'return'.</description>

			<attention>If RETURN is executed within the most upper control flow, it behaves like EXIT.</attention>

			<example>
				<![CDATA[
					<function var="getName">
						<set var="return">iXML</set>
						<return/>
						<set var="return">XML</set>
					</function>

					<call func="getName" var="name"/>
					<output>$name</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="break" title="Break-off">
			<attributes>
				<attribute name="leap" type="int" title="Leap"/>
			</attributes>

			<description>BREAK breaks out of the current control flow and continues with the execution outside the paternal control statement, though leaping over arbitrary levels of nested control statements.</description>

			<attention>If BREAK is executed within the most upper control flow or the control flow of an included code source or a subroutine, it behaves like RETURN.</attention>

			<example title="Indirect loop termination (WHILE)">
				<![CDATA[
					<set var="count">0</set>

					<while>
						<output>$count</output>
						<math:inc var="count"/>

						<if value1="$count" func="=" value2="10">
							<break/>
						</if>
					</while>

					<!-- 0123456789 -->
				]]>
			</example>

			<example title="Indirect loop termination (FOREACH)">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<output>$name</output>

						<if value1="$name" func="=" value2="Bill Gates">
							<break/>
						</if>
					</foreach>

					<!-- Bill Gates -->
				]]>
			</example>
		</command>

		<command name="next" title="Next">
			<attributes>
				<attribute name="leap" type="int" title="Leap"/>
			</attributes>

			<description>NEXT skips the rest of the current branch or loop iteration and continues with the execution of the next consecutive branch or loop iteration, though leaping over arbitrary levels of nested control statements.</description>

			<attention>If NEXT is executed outside the control flow of a multiway branch or a loop, it behaves like BREAK.</attention>

			<example title="Fall-through branch">
				<![CDATA[
					<set var="firstname">Steve</set>
					<set var="lastname">Gates</set>

					<switch value="$lastname">
						<case value="Gates">
							<if value1="$firstname" func="=" value2="Steve">
								<next/>
							</if>

							<output>My name might be Bill Gates!</output>
						</case>

						<case value="Jobs">
							<output>My name might be Steve Jobs!</output>
						</case>
					</switch>

					<!-- My name might be Steve Jobs! -->
				]]>
			</example>

			<example title="Continuation with next iteration (WHILE)">
				<![CDATA[
					<set var="count">0</set>

					<while value1="$count" func="&lt;" value2="9">
						<math:inc var="count"/>

						<if value1="$count" func="=" value2="5">
							<next/>
						</if>

						<output>$count</output>
					</while>

					<!-- 12346789 -->
				]]>
			</example>

			<example title="Continuation with next iteration (FOREACH)">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<if value1="$name" func="=" value2="Bill Gates">
							<next/>
						</if>

						<output>$name</output>
					</foreach>

					<!-- Steve Jobs -->
				]]>
			</example>
		</command>

		<command name="include" title="Include code source">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_params" type="var" title="Variable name for associated parameter name and value pairs"/>
				<attribute name="once" type="bool" title="Include just once"/>
			</attributes>

			<attributes title="Basic inclusion (non-ZeyOS)">
				<attribute name="filename" type="string" title="Filename/URL"/>
			</attributes>

			<attributes title="Object inclusion (ZeyOS)">
				<attribute name="id" type="string" title="Identifier"/>

				<attribute name="type" type="type" default="resource" title="Object type">
					<value title="Service">service</value>
					<value title="Resource">resource</value>
					<value title="Weblet">weblet</value>
				</attribute>
			</attributes>

			<content type="ixml"/>
			<result binding="var"/>

			<description>INCLUDE parses and executes an external code source, specified by a filename/URL. Arguments may be passed to local variables as parameters on switch of context.</description>

			<attention>The code source incorporates a local context when being included. Therefore local variables may be declared within the code source.</attention>
			<attention>The special local variable 'return' is a reference to the return value that is passed back as the result of INCLUDE.</attention>
			<attention>The special local variable 'arguments' is a reference to all arguments that have been passed to local variables on switch of context.</attention>
			<attention>The RETURN, BREAK and NEXT operations may be used to break-off the execution of the current code source, thereby implicitly returning to the original control flow of the invoking control statement.</attention>
		</command>

		<command name="param" title="Parameter">
			<parents>
				<parent>include</parent>
				<parent>call</parent>
				<parent>new</parent>
				<parent>zymba:run</parent>
			</parents>

			<attributes>
				<attribute name="name" type="string" default="(same as last member of 'var')" title="Name"/>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="string" title="Value"/>

			<example>
				<![CDATA[
					<function var="outputName">
						<output>$name</output>
					</function>

					<call func="outputName">
						<param name="name">iXML</param>
					</call>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="function" title="Function definition">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<children>
				<child name="use" title="Use" occurrence="multiple">
					<attributes>
						<attribute name="name" type="string" default="(same as last member of 'var')" title="Name"/>
						<attribute name="var" type="var" title="Variable name"/>
					</attributes>
				</child>
			</children>

			<content type="ixml"/>
			<result binding="var" type="function" predicate="no-result-propagation"/>

			<description>The FUNCTION construct defines a closed subroutine as a code sequence that can be invoked with subsequent CALL statements.</description>
			<description>The USE construct declares a free function variable for use as a local variable within the closure function that is explicitly bound to a corresponding variable from the immediate context within which the function is defined, thereby directly referencing the non-local variable from the parent scope outside of the inherent context of the function. The parent scope of the closure is the one in which the function is defined, not necessarily the one that the function was called from.</description>
			<description>In the context of object-oriented design, a function that corresponds to an array item is to be termed a method while the referenced array is to be termed an object.</description>
			<description>A function can be coded so that it may call itself recursively. This technique allows direct implementation of functions defined by mathematical induction and recursive divide and conquer algorithms.</description>

			<attention>The function incorporates a local context when being called. Therefore local variables may be declared within the function.</attention>
			<attention>The special local variable 'this' is a direct reference to the calling object of the method.</attention>
			<attention>The special local variable 'return' is a reference to the return value that is passed back as the result of the invoking control statement.</attention>
			<attention>The special local variable 'arguments' is a reference to all arguments that have been passed to local variables on switch of context.</attention>
			<attention>The RETURN, BREAK and NEXT operations may be used to break-off the execution of the function, thereby implicitly returning to the original control flow of the invoking control statement.</attention>

			<example title="Basic function call">
				<![CDATA[
					<global var="name"/>

					<function var="outputName">
						<output>$name</output>
					</function>

					<set var="name">iXML</set>
					<call func="outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example title="Parameterized function call">
				<![CDATA[
					<function var="outputName">
						<output>$name</output>
					</function>

					<call func="outputName">
						<param name="name">iXML</param>
					</call>

					<!-- iXML -->
				]]>
			</example>

			<example title="Method call">
				<![CDATA[
					<set var="obj.name">iXML</set>

					<function var="obj.outputName">
						<output>$this.name</output>
					</function>

					<call func="obj.outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example title="Return from function">
				<![CDATA[
					<function var="getName">
						<set var="return">iXML</set>
						<return/>
						<set var="return">XML</set>
					</function>

					<call func="getName" var="name"/>
					<output>$name</output>

					<!-- iXML -->
				]]>
			</example>

			<example title="Iterating function call">
				<![CDATA[
					<function var="outputName">
						<output>$name&n;</output>
					</function>

					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<call func="outputName">
							<param name="name">$name</param>
						</call>
					</foreach>

					<!--
					Bill Gates
					Steve Jobs
					-->
				]]>
			</example>

			<example title="Closure function call">
				<![CDATA[
					<set var="count">1</set>

					<function var="output">
						<use var="count"/>

						<output>$count&n;</output>
						<math:inc var="count"/>
					</function>

					<for from="1" to="5">
						<call func="output"/>
					</for>

					<!--
					1
					2
					3
					4
					5
					-->
				]]>
			</example>
		</command>

		<command name="call" title="Call function">
			<attributes>
				<attribute name="func" type="var" title="Function variable name"/>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_params" type="var" title="Variable name for associated parameter name and value pairs"/>
				<attribute name="var_this" type="var" title="Variable name for explicit rebinding of 'this'"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var"/>

			<description>CALL breaks out of the current control flow and continues with the execution of a function. It then returns to its original control flow. Arguments may be passed to local variables as parameters on switch of context.</description>
			<description>A function can be coded so that it may call itself recursively. This technique allows direct implementation of functions defined by mathematical induction and recursive divide and conquer algorithms.</description>

			<attention>CALL will throw an error for an undefined or invalid function.</attention>
			<attention>The function incorporates a local context when being called. Therefore local variables may be declared within the function.</attention>
			<attention>The special local variable 'this' is a direct reference to the calling object of the method.</attention>
			<attention>The special local variable 'return' is a reference to the return value that is passed back as the result of CALL.</attention>
			<attention>The special local variable 'arguments' is a reference to all arguments that have been passed to local variables on switch of context.</attention>
			<attention>The RETURN, BREAK and NEXT operations may be used to break-off the execution of the function, thereby implicitly returning to the original control flow of the invoking control statement.</attention>

			<example title="Basic function call">
				<![CDATA[
					<global var="name"/>

					<function var="outputName">
						<output>$name</output>
					</function>

					<set var="name">iXML</set>
					<call func="outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example title="Parameterized function call">
				<![CDATA[
					<function var="outputName">
						<output>$name</output>
					</function>

					<call func="outputName">
						<param name="name">iXML</param>
					</call>

					<!-- iXML -->
				]]>
			</example>

			<example title="Method call">
				<![CDATA[
					<set var="obj.name">iXML</set>

					<function var="obj.outputName">
						<output>$this.name</output>
					</function>

					<call func="obj.outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example title="Return from function">
				<![CDATA[
					<function var="getName">
						<set var="return">iXML</set>
						<return/>
						<set var="return">XML</set>
					</function>

					<call func="getName" var="name"/>
					<output>$name</output>

					<!-- iXML -->
				]]>
			</example>

			<example title="Iterating function call">
				<![CDATA[
					<function var="outputName">
						<output>$name&n;</output>
					</function>

					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<call func="outputName">
							<param name="name">$name</param>
						</call>
					</foreach>

					<!--
					Bill Gates
					Steve Jobs
					-->
				]]>
			</example>

			<example title="Closure function call">
				<![CDATA[
					<set var="count">1</set>

					<function var="output">
						<use var="count"/>

						<output>$count&n;</output>
						<math:inc var="count"/>
					</function>

					<for from="1" to="5">
						<call func="output"/>
					</for>

					<!--
					1
					2
					3
					4
					5
					-->
				]]>
			</example>

			<example title="SOAP operation call">
				<![CDATA[
					<soap:client wsdl="http://www.dneonline.com/calculator.asmx?WSDL">
						<soap:bind var="add">add</soap:bind>
					</soap:client>

					<array var="parameters">
						<item key="intA">2</item>
						<item key="intB">5</item>
					</array>

					<call func="add" var="result">
						<param var="parameters"/>
					</call>

					<output>$result.AddResult</output>

					<!-- 7 -->
				]]>
			</example>

			<example title="RESTful resource call">
				<![CDATA[
					<rest:client url="https://api.predic8.de/shop">
						<rest:header>
							Content-Type: application/json
						</rest:header>

						<rest:bind var="createProduct" method="POST">/products/</rest:bind>
						<rest:bind var="updateProduct" method="PATCH">/products/:id</rest:bind>
						<rest:bind var="getProduct" method="GET">/products/:id</rest:bind>
					</rest:client>

					<decode:json var="data">
						<call func="createProduct">
							<param>{"name": "Some Fruit", "price": 4.99}</param>
						</call>
					</decode:json>

					<match var_matches="matches" pattern="/\d+/">$data.product_url</match>
					<set var="id">$matches[0][0]</set>

					<call func="updateProduct">
						<param var="id"/>
						<param>{"name": "Wildberries"}</param>
					</call>

					<decode:json var="data">
						<call func="getProduct">
							<param var="id"/>
						</call>
					</decode:json>

					<output>$data.name</output>

					<!-- Wildberries -->
				]]>
			</example>
		</command>

		<command name="macro" title="Macro definition">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="macro" predicate="no-result-propagation"/>

			<description>The MACRO construct defines an open subroutine as a code sequence that can be expanded with subsequent EXPAND statements.</description>
			<description>Macro expansion allows for code reuse with minimal computational overhead compared to function invokation.</description>
			<description>A macro can be coded so that it may expand itself recursively. This technique allows direct implementation of functions defined by mathematical induction and recursive divide and conquer algorithms.</description>

			<attention>The macro remains within the current context when being expanded.</attention>

			<example title="Basic macro expansion">
				<![CDATA[
					<macro var="outputName">
						<output>$name</output>
					</macro>

					<set var="name">iXML</set>
					<expand macro="outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example title="Iterating macro expansion">
				<![CDATA[
					<macro var="outputName">
						<output>$name&n;</output>
					</macro>

					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<expand macro="outputName"/>
					</foreach>

					<!--
					Bill Gates
					Steve Jobs
					-->
				]]>
			</example>
		</command>

		<command name="expand" title="Expand macro">
			<attributes>
				<attribute name="macro" type="var" title="Macro variable name"/>
			</attributes>

			<description>EXPAND breaks out of the current control flow and continues with the execution of a macro. It then returns to its original control flow.</description>
			<description>Macro expansion allows for code reuse with minimal computational overhead compared to function invokation.</description>
			<description>A macro can be coded so that it may expand itself recursively. This technique allows direct implementation of functions defined by mathematical induction and recursive divide and conquer algorithms.</description>

			<attention>EXPAND will throw an error for an undefined or invalid macro.</attention>
			<attention>The macro remains within the current context when being expanded.</attention>

			<example title="Basic macro expansion">
				<![CDATA[
					<macro var="outputName">
						<output>$name</output>
					</macro>

					<set var="name">iXML</set>
					<expand macro="outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example title="Iterating macro expansion">
				<![CDATA[
					<macro var="outputName">
						<output>$name&n;</output>
					</macro>

					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<foreach var="names" var_value="name">
						<expand macro="outputName"/>
					</foreach>

					<!--
					Bill Gates
					Steve Jobs
					-->
				]]>
			</example>
		</command>

		<command name="class" title="Class definition">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<children>
				<child name="extends" title="Extends" occurrence="multiple">
					<attributes>
						<attribute name="class" type="var" title="Class variable name"/>
					</attributes>
				</child>

				<child name="property" title="Property" occurrence="multiple">
					<attributes>
						<attribute name="name" type="string" default="(same as last member of 'var')" title="Name"/>
						<attribute name="var" type="var" title="Variable name"/>
					</attributes>

					<content type="string" title="Value"/>
				</child>

				<child name="constructor" title="Constructor" occurrence="single">
					<content type="ixml"/>
				</child>

				<child name="method" title="Method" occurrence="multiple">
					<attributes>
						<attribute name="name" type="string" title="Name"/>
					</attributes>

					<content type="ixml"/>
				</child>
			</children>

			<result binding="var" type="class" predicate="no-result-propagation"/>

			<description>The CLASS construct defines a class that can be instantiated with subsequent NEW statements. It serves as an array prototype for object-oriented design.</description>
			<description>A class is used as a blueprint to create instances of itself. It defines constituent properties and methods which enable these class instances to have state and behavior. Upon instantiation the properties and methods of a class become the associated key and value pairs of a newly created array, which in the context of object-oriented design is to be termed an object.</description>
			<description>Classes can be derived from multiple existing classes, thereby establishing a hierarchial relationship in which a parent class can be considered as a common part of its subclasses. Extending a class will have the subclass inherit all the properties and methods from the parent class.</description>
			<description>The EXTENDS construct incorporates the properties, constructors and methods of a parent class, thereby overloading existing constituents.</description>
			<description>The PROPERTY construct defines a property of the class, which upon instantiation will become a regular array item with its name as the key.</description>
			<description>The CONSTRUCTOR construct defines a special type of subroutine as a code sequence that cannot be invoked directly but will automatically be called on each newly created object in order to establish the invariant of the class and put the object in some desired state upon instantiation. Upon instantiation parent constructors are automatically called along the lines of inheritance.</description>
			<description>The METHOD construct defines a closed subroutine as a code sequence analog to the FUNCTION construct but with explicit reference to the corresponding class. Upon instantiation a class method becomes a regular array item with its name as the key and the underlying function as the value.</description>

			<attention>EXTENDS will throw an error for an undefined or invalid class.</attention>
			<attention>The class variable 'class' may alternatively be an object in which case it's derived class is used instead.</attention>
			<attention>The constructors and methods incorporate a local context when being called. Therefore local variables may be declared within the constructors and methods.</attention>
			<attention>The special local variable 'this' is a direct reference to the calling object of the constructor or method.</attention>
			<attention>The special local variable 'return' is a reference to the return value that is passed back as the result of the invoking control statement.</attention>
			<attention>The special local variable 'arguments' is a reference to all arguments that have been passed to local variables on switch of context.</attention>
			<attention>The RETURN, BREAK and NEXT operations may be used to break-off the execution of the constructor or method, thereby implicitly returning to the original control flow of the invoking control statement.</attention>

			<example>
				<![CDATA[
					<class var="Human">
						<property name="gender">male</property>
					</class>

					<class var="Person">
						<extends class="Human"/>

						<property name="firstname"/>
						<property name="lastname"/>

						<constructor>
							<set var="this.firstname">$firstname</set>
							<set var="this.lastname">$lastname</set>
						</constructor>

						<method name="getName">
							<set var="return">$this.firstname $this.lastname</set>
						</method>
					</class>

					<new class="Person" var="obj">
						<param name="firstname">Bill</param>
						<param name="lastname">Gates</param>
					</new>

					<call func="obj.getName" var="name"/>
					<output>$name is $obj.gender!</output>

					<!-- Bill Gates is male! -->
				]]>
			</example>
		</command>

		<command name="new" title="New instance">
			<attributes>
				<attribute name="class" type="var" title="Class variable name"/>
				<attribute name="var" type="var" title="Object variable name"/>
				<attribute name="var_params" type="var" title="Variable name for associated parameter name and value pairs"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>NEW creates a new object by instantiating a class and automatically calling all constructors along the lines of inheritance. Arguments may be passed to local variables as parameters on switch of context.</description>

			<attention>NEW will throw an error for an undefined or invalid class.</attention>
			<attention>The class variable 'class' may alternatively be an object in which case it's derived class is used instead.</attention>
			<attention>The constructor incorporates a local context when being called. Therefore local variables may be declared within the constructors and methods.</attention>
			<attention>The special local variable 'this' is a direct reference to the calling object of the constructor.</attention>
			<attention>The special local variable 'arguments' is a reference to all arguments that have been passed to local variables on switch of context.</attention>
			<attention>The RETURN, BREAK and NEXT operations may be used to break-off the execution of the constructor, thereby implicitly returning to the original control flow of the invoking control statement.</attention>

			<example>
				<![CDATA[
					<class var="Human">
						<property name="gender">male</property>
					</class>

					<class var="Person">
						<extends class="Human"/>

						<property name="firstname"/>
						<property name="lastname"/>

						<constructor>
							<set var="this.firstname">$firstname</set>
							<set var="this.lastname">$lastname</set>
						</constructor>

						<method name="getName">
							<set var="return">$this.firstname $this.lastname</set>
						</method>
					</class>

					<new class="Person" var="obj">
						<param name="firstname">Bill</param>
						<param name="lastname">Gates</param>
					</new>

					<call func="obj.getName" var="name"/>
					<output>$name is $obj.gender!</output>

					<!-- Bill Gates is male! -->
				]]>
			</example>
		</command>

		<command name="try" title="Error handling">
			<children>
				<child name="catch" title="Error triggered execution" occurrence="single">
					<attributes>
						<attribute name="var" type="var" title="Variable name for error message"/>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="else" title="Elsewise execution" occurrence="single">
					<content type="ixml"/>
				</child>

				<child name="finally" title="Final execution" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<content type="ixml"/>

			<description>The TRY construct is a control flow structure that handles the occurrence of errors, warnings, exceptions and other special conditions that change the normal control flow.</description>
			<description>An error can be thrown and caught. Code may be surrounded by a TRY statement, to facilitate the catching of potential errors. If an error is thrown or otherwise triggered within a TRY statement, the control flow continues with the execution of the embedded CATCH statement with the error message assigned to 'var'. In case no error occurs, the control flow continues with the execution of the embedded ELSE statement instead. Eventually the control flow always continues with the execution of the embedded FINALLY statement wheter an error occurred or not.</description>

			<example title="Basic error handling">
				<![CDATA[
					<try>
						<set var="name">iXML</set>

						<if value1="$name" func="=" value2="iXML">
							<error>An error has occured!</error>
						</if>

						<catch var="error">
							<output>$error</output>
						</catch>
					</try>

					<!-- An error has occured! -->
				]]>
			</example>

			<example title="Extended error handling">
				<![CDATA[
					<try>
						<set var="name">iXML</set>

						<catch>
							<set var="output">My name is unknown!</set>
						</catch>

						<else>
							<set var="output">My name is $name!</set>
						</else>

						<finally>
							<output>$output</output>
						</finally>
					</try>

					<!-- My name is iXML! -->
				]]>
			</example>
		</command>

		<command name="error" title="Throw error">
			<content type="string" title="Error message"/>

			<description>ERROR breaks out of the current control flow by throwing an error with an error message.</description>
			<description>An error can be thrown and caught. Code may be surrounded by a TRY statement, to facilitate the catching of potential errors.</description>

			<example>
				<![CDATA[
					<try>
						<set var="name">iXML</set>

						<if value1="$name" func="=" value2="iXML">
							<error>An error has occured!</error>
						</if>

						<catch var="error">
							<output>$error</output>
						</catch>
					</try>

					<!-- An error has occured! -->
				]]>
			</example>
		</command>

		<command name="warning" title="Throw warning (ZeyOS)">
			<content type="string" title="Warning message"/>

			<description>WARNING breaks out of the current control flow by throwing a warning with a warning message.</description>
			<description>A warning can be thrown and caught. Code may be surrounded by a TRY statement, to facilitate the catching of potential warnings.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<warning>This is a warning!</warning>
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="std" title="Standard">
		<command name="global" title="Global variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<result binding="var" predicate="no-result-propagation"/>

			<description>Global declares a variable as global.</description>

			<attention>Global variables have global scope.</attention>

			<example>
				<![CDATA[
					<global var="name"/>

					<function var="outputName">
						<output>$name</output>
					</function>

					<set var="name">iXML</set>
					<call func="outputName"/>

					<!-- iXML -->
				]]>
			</example>

			<example>
				<![CDATA[
					<global var="name"/>

					<function var="setName">
						<set var="name">iXML</set>
					</function>

					<call func="setName"/>
					<output>$name</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="typeof" title="Type of variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="string">
				<value title="Undefined">undefined</value>
				<value title="NULL">null</value>
				<value title="Boolean">bool</value>
				<value title="Integer number">int</value>
				<value title="Floating point number">float</value>
				<value title="String">string</value>
				<value title="Array">array</value>
				<value title="Function">function</value>
				<value title="Macro">macro</value>
				<value title="Class">class</value>
			</result>

			<description>TYPEOF returns the intrinsic data type of a variable.</description>

			<example>
				<![CDATA[
					<set var="name">iXML</set>
					<typeof var="name" var_result="type"/>

					<if value1="$type" func="=" value2="string">
						<output>My name is a string!</output>
					</if>

					<!-- My name is a string! -->
				]]>
			</example>
		</command>

		<command name="instanceof" title="Instance of class">
			<attributes>
				<attribute name="class" type="var" title="Class variable name"/>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="bool"/>

			<description>INSTANCEOF checks whether a variable is an object of a given class.</description>

			<attention>INSTANCEOF will throw an error for an undefined or invalid class.</attention>
			<attention>The class variable 'class' may alternatively be an object in which case it's derived class is used instead.</attention>

			<example title="Class related">
				<![CDATA[
					<class var="Human"/>

					<class var="Person">
						<extends class="Human"/>

						<property name="name"/>

						<constructor>
							<set var="this.name">$name</set>
						</constructor>
					</class>

					<new class="Person" var="obj">
						<param name="name">Bill Gates</param>
					</new>

					<instanceof class="Human" var="obj" var_result="instanceof"/>

					<is var="instanceof" type="true">
						<output>$obj.name is a human!</output>
					</is>

					<!-- Bill Gates is a human! -->
				]]>
			</example>

			<example title="Object related">
				<![CDATA[
					<class var="Person">
						<property name="name"/>

						<constructor>
							<set var="this.name">$name</set>
						</constructor>
					</class>

					<new class="Person" var="obj1">
						<param name="name">Bill Gates</param>
					</new>

					<new class="Person" var="obj2">
						<param name="name">Steve Jobs</param>
					</new>

					<instanceof class="obj1" var="obj2" var_result="instanceof"/>

					<is var="instanceof" type="true">
						<output>$obj1.name is of the same class as $obj2.name!</output>
					</is>

					<!-- Bill Gates is of the same class as Steve Jobs! -->
				]]>
			</example>
		</command>

		<command name="classinfo" title="Class information">
			<attributes>
				<attribute name="class" type="var" title="Class variable name"/>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>CLASSINFO returns various components of a class.</description>
			<description>
				CLASSINFO returns an array comprised of the following items:

				Key          Description
				------------------------------------------------
				class        class
				extends      array of extended classes
				parents      array of all derived parent classes
				constructors array of constructor functions
				prototype    array prototype
			</description>

			<attention>CLASSINFO will throw an error for an undefined or invalid class.</attention>
			<attention>The class variable 'class' may alternatively be an object in which case it's derived class is used instead.</attention>

			<example title="Class related">
				<![CDATA[
					<class var="Human"/>

					<class var="Person">
						<extends class="Human"/>

						<property name="name"/>

						<constructor>
							<set var="this.name">$name</set>
						</constructor>
					</class>

					<classinfo class="Person" var="info"/>

					<foreach var="info.parents" var_value="class">
						<equals var1="class" var2="Human" var_result="equals"/>

						<is var="equals" type="true">
							<output>A person is human!</output>
							<break/>
						</is>
					</foreach>

					<!-- A person is human! -->
				]]>
			</example>

			<example title="Object related">
				<![CDATA[
					<class var="Person">
						<property name="name"/>

						<constructor>
							<set var="this.name">$name</set>
						</constructor>
					</class>

					<new class="Person" var="obj">
						<param name="name">Bill Gates</param>
					</new>

					<classinfo class="obj" var="info"/>

					<equals var1="info.class" var2="Person" var_result="equals"/>

					<is var="equals" type="true">
						<output>$obj.name is a person!</output>
					</is>

					<!-- Bill Gates is a person! -->
				]]>
			</example>
		</command>

		<command name="equals" title="Equals strictly">
			<attributes>
				<attribute name="var1" type="var" title="Variable name 1"/>
				<attribute name="var2" type="var" title="Variable name 2"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="bool"/>

			<description>EQUALS checks whether the values of two variables are strictly equal without type coercion.</description>

			<attention>Undefined variables as well as variables of different intrinsic data types are not considered equal.</attention>

			<example title="Basic equals">
				<![CDATA[
					<set var="name1">Bill Gates</set>
					<set var="name2">Steve Jobs</set>

					<equals var1="name1" var2="name2" var_result="equals"/>

					<is var="equals" type="false">
						<output>$name1 and $name2 are not strictly equal!</output>
					</is>

					<!-- Bill Gates and Steve Jobs are not strictly equal! -->
				]]>
			</example>

			<example title="Type dependent equals">
				<![CDATA[
					<set var="numeric">123</set>

					<set var="number">123</set>
					<cast var="number" type="int"/>

					<equals var1="numeric" var2="number" var_result="equals"/>

					<is var="equals" type="false">
						<output>"$numeric" and $number are not strictly equal!</output>
					</is>

					<!-- "123" and 123 are not strictly equal! -->
				]]>
			</example>
		</command>

		<command name="set" title="Set variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="key" type="string" default="(no key)" title="Key"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>SET sets the value of a variable.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<set var="var[key]">value</set>
					<set var="var.key">value</set>
					<set var="var" key="key">value</set>

					These two statements are semantically equivalent:

					<set var="var[]">value</set>
					<array:push var="var">value</array:push>
				]]>
			</description>

			<example title="Setting regular variables">
				<![CDATA[
					<set var="firstname">Bill</set>
					<set var="lastname">Gates</set>
					<output>$firstname $lastname</output>
					<!-- Bill Gates -->
				]]>
			</example>

			<example title="Setting array items implicitly">
				<![CDATA[
					<set var="names[bg]">Bill Gates</set>
					<set var="names.sj">Steve Jobs</set>
					<output>$names.bg and $names[sj] are competitors!</output>
					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>

			<example title="Setting array items explicitly">
				<![CDATA[
					<set var="names" key="bg">Bill Gates</set>
					<set var="names" key="sj">Steve Jobs</set>
					<output>$names.bg and $names[sj] are competitors!</output>
					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="unset" title="Unset variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="key" type="string" default="(no key)" title="Key"/>
			</attributes>

			<description>UNSET unsets a variable.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<unset var="var[key]"/>
					<unset var="var.key"/>
					<unset var="var" key="key"/>
				]]>
			</description>

			<attention>The TYPEOF operation will subsequently return 'undefined' for this variable.</attention>

			<example title="Unsetting variable">
				<![CDATA[
					<unset var="var"/>
				]]>
			</example>

			<example title="Unsetting array item implicitly">
				<![CDATA[
					<unset var="var[key]"/>
				]]>
			</example>

			<example title="Unsetting array item explicitly">
				<![CDATA[
					<unset var="var" key="key"/>
				]]>
			</example>
		</command>

		<command name="null" title="Set variable to NULL">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="key" type="string" default="(no key)" title="Key"/>
			</attributes>

			<result binding="var" type="null">NULL</result>

			<description>NULL sets the value of a variable to NULL.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<null var="var[key]"/>
					<null var="var.key"/>
					<null var="var" key="key"/>
				]]>
			</description>

			<example title="Setting variable to NULL">
				<![CDATA[
					<null var="var"/>
				]]>
			</example>

			<example title="Setting array item implicitly to NULL">
				<![CDATA[
					<null var="var[key]"/>
				]]>
			</example>

			<example title="Setting array item explicitly to NULL">
				<![CDATA[
					<null var="var" key="key"/>
				]]>
			</example>
		</command>

		<command name="true" title="Set variable to TRUE">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="key" type="string" default="(no key)" title="Key"/>
			</attributes>

			<result binding="var" type="bool">TRUE</result>

			<description>TRUE sets the value of a variable to TRUE.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<true var="var[key]"/>
					<true var="var.key"/>
					<true var="var" key="key"/>
				]]>
			</description>

			<example title="Setting variable to TRUE">
				<![CDATA[
					<true var="var"/>
				]]>
			</example>

			<example title="Setting array item implicitly to TRUE">
				<![CDATA[
					<true var="var[key]"/>
				]]>
			</example>

			<example title="Setting array item explicitly to TRUE">
				<![CDATA[
					<true var="var" key="key"/>
				]]>
			</example>
		</command>

		<command name="false" title="Set variable to FALSE">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="key" type="string" default="(no key)" title="Key"/>
			</attributes>

			<result binding="var" type="bool">FALSE</result>

			<description>FALSE sets the value of a variable to FALSE.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<false var="var[key]"/>
					<false var="var.key"/>
					<false var="var" key="key"/>
				]]>
			</description>

			<example title="Setting variable to FALSE">
				<![CDATA[
					<false var="var"/>
				]]>
			</example>

			<example title="Setting array item implicitly to FALSE">
				<![CDATA[
					<false var="var[key]"/>
				]]>
			</example>

			<example title="Setting array item explicitly to FALSE">
				<![CDATA[
					<false var="var" key="key"/>
				]]>
			</example>
		</command>

		<command name="assign" title="Assign variable">
			<attributes>
				<attribute name="var" type="var" title="Target variable name"/>
				<attribute name="var_source" type="var" title="Source variable name"/>
				<attribute name="key" type="string" default="(no key)" title="Target key"/>
				<attribute name="key_source" type="string" default="(no key)" title="Source key"/>
			</attributes>

			<result binding="var" predicate="no-result-propagation"/>

			<description>ASSIGN assignes the value of a source variable to a target variable.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<assign var="var[key]" var_source="var_source"/>
					<assign var="var.key" var_source="var_source"/>
					<assign var="var" key="key" var_source="var_source"/>

					These three statements are semantically equivalent:

					<assign var="var" var_source="var_source[key]"/>
					<assign var="var" var_source="var_source.key"/>
					<assign var="var" var_source="var_source" key_source="key"/>
				]]>
			</description>

			<example>
				<![CDATA[
					<set var="name1">iXML</set>
					<assign var="name2" var_source="name1"/>
					<output>$name2</output>
					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="clone" title="Clone variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(same as 'var')" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="array" predicate="no-result-propagation"/>

			<description>CLONE creates a shallow copy of the value of a variable independent of it's data type.</description>
			<description>If the result variable 'var_result' is omitted, the resulting value will be stored in 'var' instead.</description>

			<attention>CLONE preserves all meta information associated with the original variable including the class information of an object.</attention>

			<example>
				<![CDATA[
					<array var="original">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<clone var="original" var_result="new"/>
					<set var="new[1]">Larry Ellison</set>

					<output>$original[1] and $new[1] are friends!</output>

					<!-- Steve Jobs and Larry Ellison are friends! -->
				]]>
			</example>
		</command>

		<command name="swap" title="Swap variables">
			<attributes>
				<attribute name="var1" type="var" title="Variable name 1"/>
				<attribute name="var2" type="var" title="Variable name 2"/>
			</attributes>

			<result binding="var1" predicate="no-result-propagation"/>
			<result binding="var2" predicate="no-result-propagation"/>

			<description>SWAP swappes the values of two variables.</description>

			<example>
				<![CDATA[
					<set var="name1">XML</set>
					<set var="name2">iXML</set>
					<swap var1="name1" var2="name2"/>
					<output>My name is "$name1" &amp; I am a $name2 derivative!</output>
					<!-- My name is "iXML" & I am a XML derivative! -->
				]]>
			</example>
		</command>

		<command name="cast" title="Cast variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>

				<attribute name="type" type="type" default="string" title="Data type">
					<value title="Boolean">bool</value>
					<value title="Integer number">int</value>
					<value title="Floating point number">float</value>
					<value title="String">string</value>
				</attribute>
			</attributes>

			<result binding="var" type="bool|int|float|string"/>

			<description>CAST casts a variable to a given data type.</description>

			<example>
				<![CDATA[
					<set var="number">123</set>
					<cast var="number" type="int"/>

					<is var="number" type="int">
						<output>$number is now an integer number!</output>
					</is>

					<!-- 123 is now an integer number! -->
				]]>
			</example>
		</command>

		<command name="eval" title="Evaluate expression">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>

				<attribute name="type" type="type" default="string" title="Data type">
					<value title="Boolean">bool</value>
					<value title="Integer number">int</value>
					<value title="Floating point number">float</value>
					<value title="String">string</value>
				</attribute>
			</attributes>

			<content type="string" title="Expression"/>
			<result binding="var" type="bool|int|float|string"/>

			<description>EVAL evaluates an expression of a given data type.</description>

			<example>
				<![CDATA[
					<set var="dollar">$</set>
					<set var="name">iXML</set>

					<output>
						<eval>My name is $dollar$name!</eval>
					</output>

					<!-- My name is iXML! -->
				]]>
			</example>
		</command>

		<command name="serialize" title="Serialize variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="string"/>

			<description>SERIALIZE generates a storable representation of the structural value of a variable.</description>
			<description>SERIALIZE is the complement of the UNSERIALIZE operation.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<output>
						<serialize var="names"/>
					</output>

					<!-- a:2:{s:2:"bg";s:10:"Bill Gates";s:2:"sj";s:10:"Steve Jobs";} -->
				]]>
			</example>
		</command>

		<command name="unserialize" title="Unserialize variable">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Serialized value"/>
			<result binding="var"/>

			<description>UNSERIALIZE generates a structural value from a stored representation.</description>
			<description>UNSERIALIZE is the complement of the SERIALIZE operation.</description>

			<example>
				<![CDATA[
					<unserialize var="names">a:2:{s:2:"bg";s:10:"Bill Gates";s:2:"sj";s:10:"Steve Jobs";}</unserialize>
					<output>$names.bg</output>
					<!-- Bill Gates -->
				]]>
			</example>
		</command>

		<command name="length" title="String length">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="int"/>

			<description>LENGTH returns the string length of a value in characters.</description>

			<attention>The string length of a multibyte character sequence may not match the size of its binary representation.</attention>

			<example>
				<![CDATA[
					<set var="name">iXML</set>
					<length var="len">$name</length>

					<if value1="$len" func="&gt;" value2="0">
						<output>My name contains more than zero characters!</output>
					</if>

					<!-- My name contains more than zero characters! -->
				]]>
			</example>
		</command>

		<command name="size" title="Binary size">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="int"/>

			<description>SIZE returns the binary size of a value in bytes.</description>

			<attention>The binary size of a multibyte character sequence may not match the length of its string representation.</attention>

			<example>
				<![CDATA[
					<set var="name"/>
					<size var="size">$name</size>

					<if value1="$size" func="=" value2="0">
						<output>My name is empty!</output>
					</if>

					<!-- My name is empty! -->
				]]>
			</example>
		</command>

		<command name="char" title="Character of UTF-8 code">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="int" title="UTF-8 code"/>

			<result binding="var">
				<value type="string" title="UTF-8 character"/>
				<value type="null" title="No UTF-8 character">NULL</value>
			</result>

			<description>CHAR returns the specific character of an UTF-8 code.</description>

			<example>
				<![CDATA[
					<output>
						<char>65</char>
					</output>

					<!-- A -->
				]]>
			</example>
		</command>

		<command name="ord" title="Ordinal number of character">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Character"/>

			<result binding="var">
				<value type="int" title="UTF-8 code"/>
				<value type="null" title="No UTF-8 code">NULL</value>
			</result>

			<description>ORD returns the ordinal number of a character as an UTF-8 code.</description>

			<example>
				<![CDATA[
					<output>
						<ord>A</ord>
					</output>

					<!-- 65 -->
				]]>
			</example>
		</command>

		<command name="concat" title="Concatenate">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>CONCAT concatenates a value to a variable.</description>

			<example>
				<![CDATA[
					<set var="name">i</set>
					<concat var="name">XML</concat>
					<output>$name</output>
					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="tolower" title="To lower case">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>TOLOWER returns the lower case representation of a value.</description>

			<example>
				<![CDATA[
					<output>
						<tolower>iXML</tolower>
					</output>

					<!-- ixml -->
				]]>
			</example>
		</command>

		<command name="toupper" title="To upper case">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>

				<attribute name="type" type="type" default="chars" title="Capitilization type">
					<value title="All characters">chars</value>
					<value title="All words">words</value>
					<value title="First character">first</value>
				</attribute>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>TOUPPER returns the upper case representation of a value by capitalizing the first character, all words or all characters.</description>

			<example title="Capitalize first character">
				<![CDATA[
					<output>
						<toupper type="first">bill gates</toupper>
					</output>

					<!-- Bill gates -->
				]]>
			</example>

			<example title="Capitalize all words">
				<![CDATA[
					<output>
						<toupper type="words">bill gates</toupper>
					</output>

					<!-- Bill Gates -->
				]]>
			</example>

			<example title="Capitalize all characters">
				<![CDATA[
					<output>
						<toupper>iXML</toupper>
					</output>

					<!-- IXML -->
				]]>
			</example>
		</command>

		<command name="trim" title="Strip whitespaces">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>

				<attribute name="type" type="type" default="both" title="Direction type">
					<value title="From left">left</value>
					<value title="From right">right</value>
					<value title="Both">both</value>
				</attribute>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>TRIM strips whitespace characters from the beginning and/or end of a value.</description>

			<example>
				<![CDATA[
					<output>
						<trim>     iXML     </trim>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="pos" title="Position of first/last occurrence">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="value" type="string" title="Value"/>
				<attribute name="offset" type="int" title="Search offset"/>

				<attribute name="type" type="type" default="chars-first" title="Measurement type">
					<value title="First occurrence by bytes">bytes-first</value>
					<value title="Last occurrence by bytes">bytes-last</value>
					<value title="First occurrence by characters">chars-first</value>
					<value title="Last occurrence by characters">chars-last</value>
				</attribute>
			</attributes>

			<content type="string" title="Subject"/>

			<result binding="var">
				<value type="int" title="Position"/>
				<value type="null" title="Not found">NULL</value>
			</result>

			<description>POS finds the position of first or last occurrence of a value within a subject and returns the index of the corresponding byte or character if applicable.</description>
			<description>If the offset is negative it will start that many bytes or characters from the end of the subject.</description>

			<example>
				<![CDATA[
					<output>
						<pos value="X">iXML</pos>
					</output>

					<!-- 1 -->
				]]>
			</example>
		</command>

		<command name="substr" title="Substring">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="offset" type="int" title="Offset"/>
				<attribute name="length" type="int" default="(end of value)" title="Length"/>

				<attribute name="type" type="type" default="chars" title="Measurement type">
					<value title="By bytes">bytes</value>
					<value title="By characters">chars</value>
				</attribute>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>SUBSTR returns part of a value, isolated by an offset and a length.</description>
			<description>If the offset is negative it will start that many bytes or characters from the end of the value. If the length is omitted, every byte or character from the offset until the end of the value will be returned. If the length is negative then it will stop that many bytes or characters from the end of the value.</description>

			<example>
				<![CDATA[
					<output>
						<substr offset="6" length="2">Name: iXML</substr>
					</output>

					<!-- iX -->
				]]>
			</example>
		</command>

		<command name="pad" title="Pad">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="length" type="int" title="Length"/>
				<attribute name="padding" type="string" default="(space)" title="Padding value"/>

				<attribute name="type" type="type" default="chars" title="Measurement type">
					<value title="By bytes">bytes</value>
					<value title="By characters">chars</value>
				</attribute>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>PAD pads a value to a given length.</description>
			<description>If the length is positive then the value is padded on the right, if it is negative then on the left. If the padding value is empty or the absolute length is less than or equal to the actual length of the value then no padding takes place.</description>

			<example>
				<![CDATA[
					<output>
						<pad length="-10" padding="0">123</pad>
					</output>

					<!-- 0000000123 -->
				]]>
			</example>
		</command>

		<command name="match" title="Regular expression match">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for number of matches"/>
				<attribute name="var_matches" type="var" title="Result variable name for actual matches"/>
				<attribute name="pattern" type="regexp" title="Pattern"/>
				<attribute name="offset" type="int" title="Search offset"/>
			</attributes>

			<content type="string" title="Subject"/>
			<result binding="var" type="int"/>
			<result binding="var_matches" type="array" predicate="no-result-propagation"/>

			<description>MATCH performs a global regular expression match on a subject against a given pattern and assignes the number of full matches to 'var', while the actual matches are assigned to 'var_matches'.</description>
			<description>Results are ordered so that matches[0] is an array of first set of matches, matches[1] is an array of second set of matches, and so on.</description>
		 <description>If the offset is negative it will start that many characters from the end of the subject.</description>

			<example>
				<![CDATA[
					<match var="count" var_matches="matches" pattern="/ixml/i">My name is iXML!</match>

					<if value1="$count" func="&gt;" value2="0">
						<output>$matches[0][0]</output>
					</if>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="replace" title="Search and replace">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_count" type="var" title="Result variable name for number of replacements"/>
				<attribute name="replacement" type="string" title="Replacement value"/>
				<attribute name="limit" type="int" default="(no limit)" title="Limit"/>
			</attributes>

			<attributes title="Basic">
				<attribute name="value" type="string" title="Search value"/>
			</attributes>

			<attributes title="Regular expression">
				<attribute name="pattern" type="regexp" title="Search pattern"/>
			</attributes>

			<content type="string" title="Subject"/>
			<result binding="var" type="string"/>

			<description>REPLACE searches a subject for occurrences of a given search value or matches to a given search pattern and replaces them with a given replacement value. The number of actual replacements is assigned to 'var_count'.</description>
			<description>The replacement value of a regular expression may contain backreferences of the form '\n'. Every such reference will be replaced by the text captured by the n'th parenthesized pattern. '\0' always refers to the text matched by the entire search pattern.</description>

			<example title="Basic search and replace">
				<![CDATA[
					<output>
						<replace value="Bill Gates" replacement="William Henry Gates III">My name is Bill Gates!</replace>
					</output>

					<!-- My name is William Henry Gates III! -->
				]]>
			</example>

			<example title="Regular expression search and replace">
				<![CDATA[
					<output>
						<replace pattern="/B[il]+\s*G\w+/" replacement="William Henry Gates III">My name is Bill Gates!</replace>
					</output>

					<!-- My name is William Henry Gates III! -->
				]]>
			</example>

			<example title="Search and replace using backreferences">
				<![CDATA[
					<output>
						<replace pattern="/Bill ([a-z]+)/i" replacement="William Henry \1 III, call me \0">My name is Bill Gates!</replace>
					</output>

					<!-- My name is William Henry Gates III, call me Bill Gates! -->
				]]>
			</example>
		</command>

		<command name="split" title="Split">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="limit" type="int" default="(no limit)" title="Limit"/>
			</attributes>

			<attributes title="Basic">
				<attribute name="delimiter" type="string" title="Delimiter"/>
			</attributes>

			<attributes title="Regular expression">
				<attribute name="pattern" type="regexp" title="Pattern"/>
			</attributes>

			<content type="string" title="Subject"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>SPLIT splits a subject along boundaries formed by a given delimiter or matched by a given pattern.</description>

			<example title="Basic split">
				<![CDATA[
					<split var="names" delimiter=", ">Bill Gates, Steve Jobs</split>
					<output>$names[0]</output>
					<!-- Bill Gates -->
				]]>
			</example>

			<example title="Regular expression split">
				<![CDATA[
					<split var="names" pattern="/,\s?/">Bill Gates, Steve Jobs</split>
					<output>$names[1]</output>
					<!-- Steve Jobs -->
				]]>
			</example>
		</command>

		<command name="convert" title="Convert character encoding">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="from" type="type" default="UTF-8" title="Source character set"/>
				<attribute name="to" type="type" default="UTF-8" title="Target character set"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>CONVERT converts the character encoding of a value from a source character set to a target character set.</description>
		</command>

		<command name="output" title="Output">
			<content type="string" title="Value"/>

			<description>OUTPUT outputs a value.</description>

			<example>
				<![CDATA[
					<output>Hello World!</output>
					<!-- Hello World! -->
				]]>
			</example>
		</command>

		<command name="header" title="Set HTTP header">
			<attributes>
				<attribute name="status" type="int" title="HTTP status code"/>
			</attributes>

			<content type="string" title="Header"/>

			<description>HEADER sets a single HTTP response header field and optionally resets the HTTP response status code.</description>

			<attention>All header fields must be sent before any actual output is sent.</attention>

			<example>
				<![CDATA[
					<header>Content-Type: text/plain</header>
				]]>
			</example>
		</command>

		<command name="sleep" title="Sleep">
			<content type="float" default="1" title="Duration"/>

			<description>SLEEP execution for a specific duration in number of seconds.</description>
			<description>The duration may include micro seconds in the fractional part.</description>

			<example>
				<![CDATA[
					<sleep>0.1</sleep>
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="math" title="Mathematics">
		<command name="math:abs" title="Absolute number">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ABS returns the absolute number of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:abs>-13.74</math:abs>
					</output>

					<!-- 13.74 -->
				]]>
			</example>
		</command>

		<command name="math:sign" title="Extract sign">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>

			<result binding="var" type="int">
				<value title="Positive">1</value>
				<value title="Zero">0</value>
				<value title="Negative">-1</value>
			</result>

			<description>MATH:SIGN extracts the sign of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:sign>-13.74</math:sign>
					</output>

					<!-- -1 -->
				]]>
			</example>
		</command>

		<command name="math:inc" title="Increment variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="int" default="1" title="Value"/>
			<result binding="var" type="int"/>

			<description>MATH:INC increments the value of a variable.</description>

			<example>
				<![CDATA[
					<set var="number">1</set>
					<math:inc var="number"/>
					<output>$number</output>
					<!-- 2 -->
				]]>
			</example>
		</command>

		<command name="math:dec" title="Decrement variable">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="int" default="1" title="Value"/>
			<result binding="var" type="int"/>

			<description>MATH:DEC decrements the value of a variable.</description>

			<example>
				<![CDATA[
					<set var="number">2</set>
					<math:dec var="number"/>
					<output>$number</output>
					<!-- 1 -->
				]]>
			</example>
		</command>

		<command name="math:mod" title="Floating point modulo">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="x" type="float" title="Numerator"/>
				<attribute name="y" type="float" title="Denominator"/>
			</attributes>

			<result binding="var" type="float"/>

			<description>MATH:MOD calculates the floating point remainder of the division of two values (x/y).</description>

			<example>
				<![CDATA[
					<output>
						<math:mod x="5.72" y="1.38"/>
					</output>

					<!-- 0.2 -->
				]]>
			</example>
		</command>

		<command name="math:exp" title="Exponent of Euler's constant">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Power"/>
			<result binding="var" type="float"/>

			<description>MATH:EXP raises Euler's constant (e) to a given power.</description>

			<example>
				<![CDATA[
					<output>
						<math:exp>10</math:exp>
					</output>

					<!-- 22026.465794807 -->
				]]>
			</example>
		</command>

		<command name="math:ln" title="Natural logarithm">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:LN calculates the natural logarithm of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:ln>22026.465794807</math:ln>
					</output>

					<!-- 10 -->
				]]>
			</example>
		</command>

		<command name="math:log" title="Logarithm">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="base" type="int" default="10" title="Logarithmic base"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:LOG calculates the logarithm of a value using a given logarithmic base.</description>

			<example>
				<![CDATA[
					<output>
						<math:log base="2">1024</math:log>
					</output>

					<!-- 10 -->
				]]>
			</example>
		</command>

		<command name="math:pow" title="Raise to power">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="exponent" type="int" default="2" title="Exponent"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:POW raises a value to the power of an exponent.</description>

			<example>
				<![CDATA[
					<output>
						<math:pow exponent="10">2</math:pow>
					</output>

					<!-- 1024 -->
				]]>
			</example>
		</command>

		<command name="math:sqrt" title="Square root">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:SQRT calculates the square root of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:sqrt>25</math:sqrt>
					</output>

					<!-- 5 -->
				]]>
			</example>
		</command>

		<command name="math:hypot" title="Hypotenuse">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="x" type="float" title="Abscissa"/>
				<attribute name="y" type="float" title="Ordinate"/>
			</attributes>

			<result binding="var" type="float"/>

			<description>MATH:HYPOT calculates the length of the hypotenuse of a right-angle triangle.</description>

			<example>
				<![CDATA[
					<output>
						<math:hypot x="3" y="5"/>
					</output>

					<!-- 5.8309518948453 -->
				]]>
			</example>
		</command>

		<command name="math:pi" title="PI">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="float"/>

			<description>MATH:PI returns the circle constant (Ï).</description>

			<example>
				<![CDATA[
					<output>
						<math:pi/>
					</output>

					<!-- 3.1415926535898 -->
				]]>
			</example>
		</command>

		<command name="math:sin" title="Sine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:SIN calculates the sine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:sin>1</math:sin>
					</output>

					<!-- 0.8414709848079 -->
				]]>
			</example>
		</command>

		<command name="math:sinh" title="Hyperbolic sine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:SINH calculates the hyperbolic sine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:sinh>1</math:sinh>
					</output>

					<!-- 1.1752011936438 -->
				]]>
			</example>
		</command>

		<command name="math:asin" title="Arc sine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ASIN calculates the inverse sine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:asin>1</math:asin>
					</output>

					<!-- 1.5707963267949 -->
				]]>
			</example>
		</command>

		<command name="math:asinh" title="Arc hyperbolic sine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ASINH calculates the inverse hyperbolic sine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:asinh>1</math:asinh>
					</output>

					<!-- 0.88137358701954 -->
				]]>
			</example>
		</command>

		<command name="math:cos" title="Cosine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:COS calculates the cosine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:cos>1</math:cos>
					</output>

					<!-- 0.54030230586814 -->
				]]>
			</example>
		</command>

		<command name="math:cosh" title="Hyperbolic cosine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:COSH calculates the hyperbolic cosine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:cosh>1</math:cosh>
					</output>

					<!-- 1.5430806348152 -->
				]]>
			</example>
		</command>

		<command name="math:acos" title="Arc cosine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ACOS calculates the inverse cosine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:acos>1</math:acos>
					</output>

					<!-- 0 -->
				]]>
			</example>
		</command>

		<command name="math:acosh" title="Arc hyperbolic cosine">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ACOSH calculates the inverse hyperbolic cosine of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:acosh>1</math:acosh>
					</output>

					<!-- 0 -->
				]]>
			</example>
		</command>

		<command name="math:tan" title="Tangent">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:TAN calculates the tangent of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:tan>1</math:tan>
					</output>

					<!-- 1.5574077246549 -->
				]]>
			</example>
		</command>

		<command name="math:tanh" title="Hyperbolic tangent">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:TANH calculates the hyperbolic tangent of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:tanh>1</math:tanh>
					</output>

					<!-- 0.76159415595576 -->
				]]>
			</example>
		</command>

		<command name="math:atan" title="Arc tangent">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ATAN calculates the inverse tangent of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:atan>1</math:atan>
					</output>

					<!-- 0.78539816339745 -->
				]]>
			</example>
		</command>

		<command name="math:atanh" title="Arc hyperbolic tangent">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ATANH calculates the inverse hyperbolic tangent of a value.</description>

			<example>
				<![CDATA[
					<output>
						<math:atanh>0</math:atanh>
					</output>

					<!-- 0 -->
				]]>
			</example>
		</command>

		<command name="math:atan2" title="Arc tangent of y/x">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="x" type="float" title="Abscissa"/>
				<attribute name="y" type="float" title="Ordinate"/>
			</attributes>

			<result binding="var" type="float"/>

			<description>MATH:ATAN2 calculates the inverse tangent of the division of two values (y/x) using the sign of both values to determine the quadrant.</description>

			<example>
				<![CDATA[
					<output>
						<math:atan2 x="3" y="5"/>
					</output>

					<!-- 1.0303768265243 -->
				]]>
			</example>
		</command>

		<command name="math:round" title="Round">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="precision" type="int" title="Precision"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:ROUND rounds a value half away from zero to a number of decimal digits, specified by a given precision.</description>

			<example>
				<![CDATA[
					<output>
						<math:round precision="2">17.213482971852</math:round>
					</output>

					<!-- 17.21 -->
				]]>
			</example>
		</command>

		<command name="math:ceil" title="Round fractions up">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:CEIL rounds a value up to the next highest integer number.</description>

			<example>
				<![CDATA[
					<output>
						<math:ceil>17.213482971852</math:ceil>
					</output>

					<!-- 18 -->
				]]>
			</example>
		</command>

		<command name="math:floor" title="Round fractions down">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="float"/>

			<description>MATH:FLOOR rounds a value down to the next lowest integer number.</description>

			<example>
				<![CDATA[
					<output>
						<math:floor>17.213482971852</math:floor>
					</output>

					<!-- 17 -->
				]]>
			</example>
		</command>

		<command name="math:rand" title="Random number">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="min" type="int" title="Minimum number"/>
				<attribute name="max" type="int" default="(largest possible integer number)" title="Maximum number"/>
			</attributes>

			<result binding="var" type="float"/>

			<description>MATH:RAND generates a random number between a given numeric range.</description>
			<description>If the maximum number is omitted, it will range up to the largest possible integer number.</description>

			<example>
				<![CDATA[
					<output>
						<math:rand/>
					</output>
				]]>
			</example>
		</command>

		<command name="math:convert" title="Convert number">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>

				<attribute name="from" type="type" default="dec" title="Source representation">
					<value title="Binary">bin</value>
					<value title="Octal">oct</value>
					<value title="Decimal">dec</value>
					<value title="Hexadecimal">hex</value>
					<value title="Degrees (decimal)">deg</value>
					<value title="Radian (decimal)">rad</value>
				</attribute>

				<attribute name="to" type="type" default="dec" title="Target representation">
					<value title="Binary">bin</value>
					<value title="Octal">oct</value>
					<value title="Decimal">dec</value>
					<value title="Hexadecimal">hex</value>
					<value title="Degrees (decimal)">deg</value>
					<value title="Radian (decimal)">rad</value>
				</attribute>
			</attributes>

			<content title="Value"/>
			<result binding="var" type="int|float|string"/>

			<description>MATH:CONVERT converts the number representation of a value from a source representation to a target representation.</description>

			<example>
				<![CDATA[
					<output>
						<math:convert from="hex" to="bin">7cd5a72c</math:convert>
					</output>

					<!-- 1111100110101011010011100101100 -->
				]]>
			</example>
		</command>

		<command name="math:format" title="Format number">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="countdec" type="int" title="Number of decimal digits"/>
				<attribute name="decpoint" type="string" default="." title="Decimal point"/>
				<attribute name="separator" type="string" default="," title="Thousands separator"/>
			</attributes>

			<content type="float" title="Value"/>
			<result binding="var" type="string"/>

			<description>MATH:FORMAT returns the formatted representation of a value with a fixed number of decimal digits and grouped thousands.</description>

			<example>
				<![CDATA[
					<output>
						<math:format countdec="2">1792702.213482971852</math:format>
					</output>

					<!-- 1,792,702.21 -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="date" title="Date and time">
		<command name="date:now" title="Current timestamp">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="micro" type="bool" title="Include micro seconds"/>
			</attributes>

			<result binding="var" type="int|float"/>

			<description>DATE:NOW returns the timestamp for the current date and time. The timestamp may optionally include micro seconds in the fractional part.</description>
			<description>Timestamps are based on Unix time, defined as the number of seconds elapsed since midnight proleptic Coordinated Universal Time (UTC) of January 1, 1970, not counting leap seconds.</description>

			<example>
				<![CDATA[
					<output>
						<date:now/>
					</output>
				]]>
			</example>
		</command>

		<command name="date:info" title="Date information">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="timezone" type="string" default="(system time zone)" title="Time zone"/>
			</attributes>

			<content type="int" default="(current date and time)" title="Timestamp"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>DATE:INFO returns the various components of a date and time.</description>
			<description>
				DATE:INFO returns an array comprised of the following items:

				Key    Description
				---------------------------------------------
				day    Day (1..31)
				month  Month (1..12)
				year   Year, 4 digits
				hour   Hour (0..59)
				minute Minute (0..59)
				second Second (0..59)
				wday   Day of week, Sunday to Saturday (0..6)
				yday   Day of year (0..365)
			</description>
		</command>

		<command name="date:create" title="Create timestamp">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="day" type="int" title="Day"/>
				<attribute name="month" type="int" title="Month"/>
				<attribute name="year" type="int" title="Year"/>
				<attribute name="hour" type="int" title="Hour"/>
				<attribute name="minute" type="int" title="Minute"/>
				<attribute name="second" type="int" title="Second"/>
				<attribute name="timezone" type="string" default="(system time zone)" title="Time zone"/>
			</attributes>

			<result binding="var">
				<value type="int" title="Date"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>DATE:CREATE creates the timestamp for a date, specified by day, month, year, hour, minute and second.</description>
			<description>Timestamps are based on Unix time, defined as the number of seconds elapsed since midnight proleptic Coordinated Universal Time (UTC) of January 1, 1970, not counting leap seconds.</description>

			<example>
				<![CDATA[
					<output>
						<date:create day="1" month="1" year="2000"/>
					</output>

					<!-- 946684800 -->
				]]>
			</example>
		</command>

		<command name="date:parse" title="Parse date and time">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="timezone" type="string" default="(system time zone)" title="Time zone"/>
			</attributes>

			<content type="string" title="Value"/>

			<result binding="var">
				<value type="int" title="Date"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>DATE:PARSE returns the timestamp for a date by parsing a textual date and time value.</description>
			<description>Timestamps are based on Unix time, defined as the number of seconds elapsed since midnight proleptic Coordinated Universal Time (UTC) of January 1, 1970, not counting leap seconds.</description>

			<example>
				<![CDATA[
					<output>
						<date:parse>2000-01-01</date:parse>
					</output>

					<!-- 946684800 -->
				]]>
			</example>
		</command>

		<command name="date:format" title="Format timestamp">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="format" type="string" default="c" title="Format"/>
				<attribute name="timezone" type="string" default="(system time zone)" title="Time zone"/>
			</attributes>

			<content type="date" default="(current date and time)" title="Timestamp"/>
			<result binding="var" type="string"/>

			<description>DATE:FORMAT returns the formatted representation of a timestamp according to a given PHP-compatible format.</description>
			<description>Timestamps are based on Unix time, defined as the number of seconds elapsed since midnight proleptic Coordinated Universal Time (UTC) of January 1, 1970, not counting leap seconds.</description>

			<example>
				<![CDATA[
					<output>
						<date:format format="Y-m-d">946684800</date:format>
					</output>

					<!-- 2000-01-01 -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="array" title="Array">
		<command name="array" title="Build array">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="key" type="string" default="(next consecutive numeric key)" title="Key"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>ARRAY builds an array with associated key and value pairs. It may be deeply nested in order to build a multidimensional array.</description>
			<description>If the key is omitted within ARRAY or ITEM, a consecutive numeric key will implicitly be generated.</description>

			<example title="Array with explicit keys">
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<output>$names.bg and $names.sj are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>

			<example title="Array with implicit numeric keys">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="item" title="Array item">
			<parents>
				<parent>array</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="key" type="string" default="(next consecutive numeric key)" title="Key"/>
			</attributes>

			<content type="string" title="Value"/>
		</command>

		<command name="array:range" title="Array range">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="from" type="int" title="From"/>
				<attribute name="to" type="int" title="To"/>
				<attribute name="step" type="int" default="1" title="Step"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:RANGE creates an array with values of a given numeric range.</description>
			<description>ARRAY:RANGE will implicitly generate a consecutive numeric key for each item of the numeric range.</description>

			<attention>If the given step is less than one, the array will be empty.</attention>

			<example title="Incremental range">
				<![CDATA[
					<array:range var="range" from="6" to="10" step="2"/>

					<output>
						<array:join var="range" delimiter=", "/>
					</output>

					<!-- 6, 8, 10 -->
				]]>
			</example>

			<example title="Decremental range">
				<![CDATA[
					<array:range var="range" from="10" to="6" step="2"/>

					<output>
						<array:join var="range" delimiter=", "/>
					</output>

					<!-- 10, 8, 6  -->
				]]>
			</example>
		</command>

		<command name="array:assoc" title="Associate keys and values">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_keys" type="var" title="Variable name for keys"/>
				<attribute name="var_values" type="var" title="Variable name for values"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:ASSOC creates an array of associated key and value pairs by combining two separate arrays of keys and values.</description>

			<example>
				<![CDATA[
					<array var="keys">
						<item>bg</item>
						<item>sj</item>
					</array>

					<array var="values">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array:assoc var="names" var_keys="keys" var_values="values"/>
					<output>$names.bg and $names.sj are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:populate" title="Populate array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="prefix" type="string" title="Prefix"/>
			</attributes>

			<description>ARRAY:POPULATE imports all associated key and value pairs from an array into the local variable scope by treating keys as variable names, expanded by a given prefix, and values as non-referential variable values.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array:populate var="names" prefix="n_"/>
					<output>$n_bg and $n_sj are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:length" title="Array length">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="int"/>

			<description>ARRAY:LENGTH returns the number of items in an array.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array:length var="names" var_result="len"/>

					<if value1="$len" func="&gt;" value2="0">
						<output>There are names available!</output>
					</if>

					<!-- There are names available! -->
				]]>
			</example>
		</command>

		<command name="array:keyexists" title="Array key exists">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Key"/>
			<result binding="var_result" type="bool"/>

			<description>ARRAY:KEYEXISTS checks whether a key exists within an array.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array:keyexists var="names" var_result="exists">sj</array:keyexists>

					<is var="exists" type="true">
						<output>Key exists!</output>
					</is>

					<!-- Key exists! -->
				]]>
			</example>
		</command>

		<command name="array:valueexists" title="Array value exists">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var_result" type="bool"/>

			<description>ARRAY:VALUEEXISTS checks whether a value exists within an array.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array:valueexists var="names" var_result="exists">Steve Jobs</array:valueexists>

					<is var="exists" type="true">
						<output>Value exists!</output>
					</is>

					<!-- Value exists! -->
				]]>
			</example>
		</command>

		<command name="array:pos" title="Position of first/last occurrence">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
				<attribute name="offset" type="int" title="Search offset"/>

				<attribute name="type" type="type" default="first" title="Measurement type">
					<value title="First occurrence">first</value>
					<value title="Last occurrence">last</value>
				</attribute>
			</attributes>

			<content type="string" title="Value"/>

			<result binding="var_result">
				<value type="int|string" title="Key"/>
				<value type="null" title="Not found">NULL</value>
			</result>

			<description>ARRAY:POS finds the position of first or last occurrence of a value within an array and returns the key of the corresponding array item if applicable.</description>
			<description>If the offset is negative it will start that many items from the end of the array.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<output>
						<array:pos var="names">Steve Jobs</array:pos>
					</output>

					<!-- 1 -->
				]]>
			</example>
		</command>

		<command name="array:first" title="First array item">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_key" type="var" title="Result variable name for key"/>
				<attribute name="var_value" type="var" title="Result variable name for value"/>
			</attributes>

			<result binding="var_key" predicate="no-result-propagation">
				<value type="int|string" title="Key"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<result binding="var_value">
				<value title="Value"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<description>ARRAY:FIRST returns the first item of an array.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="js">Steve Jobs</item>
					</array>

					<output>
						<array:first var="names"/>
					</output>

					<!-- Bill Gates -->
				]]>
			</example>
		</command>

		<command name="array:last" title="Last array item">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_key" type="var" title="Result variable name for key"/>
				<attribute name="var_value" type="var" title="Result variable name for value"/>
			</attributes>

			<result binding="var_key" predicate="no-result-propagation">
				<value type="int|string" title="Key"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<result binding="var_value">
				<value title="Value"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<description>ARRAY:LAST returns the last item of an array.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="js">Steve Jobs</item>
					</array>

					<output>
						<array:last var="names"/>
					</output>

					<!-- Steve Jobs -->
				]]>
			</example>
		</command>

		<command name="array:rand" title="Random array item">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_key" type="var" title="Result variable name for key"/>
				<attribute name="var_value" type="var" title="Result variable name for value"/>
			</attributes>

			<result binding="var_key" predicate="no-result-propagation">
				<value type="int|string" title="Key"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<result binding="var_value">
				<value title="Value"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<description>ARRAY:RAND returns a random item of an array.</description>
		</command>

		<command name="array:push" title="Push onto array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:PUSH pushes a value onto the end of an array.</description>
			<description>ARRAY:PUSH will implicitly generate a consecutive numeric key.</description>
			<description>
				<![CDATA[
					These three statements are semantically equivalent:

					<array:push var="var">value</array:push>
					<set var="var[]">value</set>
				]]>
			</description>

			<attention>ARRAY:PUSH is destructive, in the sense that it modifies the array in-place. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
					</array>

					<array:push var="names">Steve Jobs</array:push>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:pop" title="Pop off array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<result binding="var_result">
				<value title="Result"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<description>ARRAY:POP pops an item off the end of an array and returns its value.</description>

			<attention>ARRAY:POP is destructive, in the sense that it modifies the array in-place. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<output>
						<array:pop var="names"/>
					</output>

					<!-- Steve Jobs -->
				]]>
			</example>
		</command>

		<command name="array:shift" title="Shift off array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<result binding="var_result">
				<value title="Result"/>
				<value type="null" title="Empty array">NULL</value>
			</result>

			<description>ARRAY:SHIFT shifts an item off the beginning of an array and returns its value.</description>

			<attention>ARRAY:SHIFT is destructive, in the sense that it modifies the array in-place. It will re-index all numeric keys in the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<output>
						<array:shift var="names"/>
					</output>

					<!-- Bill Gates -->
				]]>
			</example>
		</command>

		<command name="array:unshift" title="Prepend to array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:UNSHIFT prepends a value to the beginning of an array.</description>

			<attention>ARRAY:UNSHIFT is destructive, in the sense that it modifies the array in-place. It will re-index all numeric keys in the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
					</array>

					<array:unshift var="names">Steve Jobs</array:unshift>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Steve Jobs and Bill Gates are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:concat" title="Concatenate array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
				<attribute name="var_tail" type="var" title="Tail variable name"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:CONCAT concatenates the items of the tail array to an array.</description>
			<description>ARRAY:CONCAT will implicitly generate a consecutive numeric key for each item of the tail array.</description>

			<attention>ARRAY:CONCAT is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
					</array>

					<array var="addition">
						<item>Steve Jobs</item>
					</array>

					<array:concat var="names" var_tail="addition"/>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:slice" title="Slice array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
				<attribute name="offset" type="int" title="Offset"/>
				<attribute name="length" type="int" default="(end of array)" title="Length"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:SLICE slices part of an array, isolated by an offset and a length.</description>
			<description>If the offset is negative it will start that many items from the end of the array. If the length is omitted, every item from the offset until the end of the array will be returned. If the length is negative then it will stop that many items from the end of the array.</description>

			<attention>ARRAY:SLICE is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array:slice var="names" offset="1" length="2"/>

					<output>
						<array:join var="names" delimiter=", "/>
					</output>

					<!-- Steve Jobs, Larry Ellison -->
				]]>
			</example>
		</command>

		<command name="array:extract" title="Extract array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_replacement" type="var" title="Replacement variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
				<attribute name="offset" type="int" title="Offset"/>
				<attribute name="length" type="int" default="(end of array)" title="Length"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>
			<result binding="var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:EXTRACT extracts and replaces part of an array, isolated by an offset and a length.</description>
			<description>If the offset is negative it will start that many items from the end of the array. If the length is omitted, every item from the offset until the end of the array will be returned. If the length is negative then it will stop that many items from the end of the array.</description>

			<attention>ARRAY:EXTRACT is destructive, in the sense that it modifies the array in-place. It will re-index all keys in the array numerically.</attention>

			<example title="Extraction">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array:extract var="names" var_result="extract" offset="1" length="2"/>
					<output>$extract[0] and $extract[1] are friends!</output>

					<!-- Steve Jobs and Larry Ellison are friends! -->
				]]>
			</example>

			<example title="Replacement">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Larry Ellison</item>
					</array>

					<array var="replacement">
						<item>Steve Jobs</item>
					</array>

					<array:extract var="names" var_replacement="replacement" length="1"/>
					<output>$names[0] and $names[1] are friends!</output>

					<!-- Steve Jobs and Larry Ellison are friends! -->
				]]>
			</example>
		</command>

		<command name="array:pad" title="Pad array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
				<attribute name="length" type="int" title="Length"/>
				<attribute name="padding" type="string" default="(NULL)" title="Padding value"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:PAD pads an array to a given length.</description>
			<description>If the length is positive then the array is padded on the right, if it is negative then on the left. If the absolute length is less than or equal to the actual length of the array then no padding takes place.</description>

			<attention>ARRAY:PAD is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It will re-index all keys in the array numerically.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array:pad var="names" length="3" padding="Larry Ellison"/>
					<output>$names[1] and $names[2] are friends!</output>

					<!-- Steve Jobs and Larry Ellison are friends! -->
				]]>
			</example>
		</command>

		<command name="array:reverse" title="Reverse array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:REVERSE reverses the item order of an array.</description>

			<attention>ARRAY:REVERSE is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array:reverse var="names"/>

					<foreach var="names" var_value="name">
						<output>$name&n;</output>
					</foreach>

					<!--
					Steve Jobs
					Bill Gates
					-->
				]]>
			</example>
		</command>

		<command name="array:flip" title="Flip array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:FLIP exchanges all keys in an array with their associated values.</description>

			<attention>ARRAY:FLIP is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. A distinct array with string-recasted values as keys will be created. If a value has several occurrences within the array, only the last key will be used while all other items with that particular key will be discarded.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array:flip var="names"/>
					<output>$names[Bill Gates] and $names[Steve Jobs] are competitors!</output>

					<!-- bg and sj are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:unique" title="Unique array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:UNIQUE discards duplicate items from an array, keeping only the first occurrence of each value.</description>
			<description>A given key may specify the column of a multidimensional array to distinguish by. If however, the key is omitted, then the array is treated as an unidimensional list.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be discarded.</attention>
			<attention>ARRAY:UNIQUE is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. If a value has several occurrences within the array, only the first key will be used while all other items with that particular key will be discarded.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg1">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
						<item key="bg2">Bill Gates</item>
					</array>

					<array:unique var="names"/>

					<foreach var="names" var_key="key" var_value="name">
						<output>$key: $name&n;</output>
					</foreach>

					<!--
					bg1: Bill Gates
					sj: Steve Jobs
					-->
				]]>
			</example>
		</command>

		<command name="array:merge" title="Array merging">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_set" type="var" title="Set variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:MERGE merges an array with the set array, whereas duplicated non-numeric keys are overwritten while items with numeric keys are appended.</description>

			<attention>ARRAY:MERGE is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It partially preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
					</array>

					<array var="addition">
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array:merge var="names" var_set="addition"/>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:complement" title="Array complement">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_set" type="var" title="Set variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>

				<attribute name="type" type="type" default="values" title="Complement type">
					<value title="By keys">keys</value>
					<value title="By values">values</value>
				</attribute>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:COMPLEMENT generates the relative complement of two arrays by extracting those items of an array that do not exist within the set array.</description>

			<attention>ARRAY:COMPLEMENT is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example title="Complement by keys">
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
						<item key="le">Larry Ellison</item>
					</array>

					<array var="complement">
						<item key="bg">Bill Gates</item>
					</array>

					<array:complement var="names" var_set="complement" type="keys"/>
					<output>$names.sj and $names.le are friends!</output>

					<!-- Steve Jobs and Larry Ellison are friends! -->
				]]>
			</example>

			<example title="Complement by values">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array var="complement">
						<item>Bill Gates</item>
					</array>

					<array:complement var="names" var_set="complement" type="values"/>
					<output>$names[1] and $names[2] are friends!</output>

					<!-- Steve Jobs and Larry Ellison are friends! -->
				]]>
			</example>
		</command>

		<command name="array:diff" title="Array difference">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_set" type="var" title="Set variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>

				<attribute name="type" type="type" default="values" title="Difference type">
					<value title="By keys">keys</value>
					<value title="By values">values</value>
				</attribute>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:DIFF generates the symmetric difference of two arrays by merging those items of both arrays that do not exist within both arrays together, whereas duplicated non-numeric keys are overwritten while items with numeric keys are appended.</description>

			<attention>ARRAY:DIFF is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It partially preserves the key and value associations of the array.</attention>

			<example title="Difference by keys">
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array var="diff">
						<item key="sj">Steve Jobs</item>
						<item key="le">Larry Ellison</item>
					</array>

					<array:diff var="names" var_set="diff" type="keys"/>
					<output>$names.bg and $names.le are competitors!</output>

					<!-- Bill Gates and Larry Ellison are competitors! -->
				]]>
			</example>

			<example title="Difference by values">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array var="diff">
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array:diff var="names" var_set="diff" type="values"/>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Larry Ellison are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:intersect" title="Array intersection">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_set" type="var" title="Set variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>

				<attribute name="type" type="type" default="values" title="Intersection type">
					<value title="By keys">keys</value>
					<value title="By values">values</value>
				</attribute>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:INTERSECT generates the intersection of two arrays by extracting those items of an array that also exist within the set array.</description>

			<attention>ARRAY:INTERSECT is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example title="Intersection by keys">
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array var="intersect">
						<item key="sj">Steve Jobs</item>
						<item key="le">Larry Ellison</item>
						<item key="bg">Bill Gates</item>
					</array>

					<array:intersect var="names" var_set="intersect" type="keys"/>
					<output>$names.bg and $names.sj are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>

			<example title="Intersection by values">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
					</array>

					<array var="intersect">
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
						<item>Bill Gates</item>
					</array>

					<array:intersect var="names" var_set="intersect" type="values"/>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:union" title="Array union">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_set" type="var" title="Set variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>

				<attribute name="type" type="type" default="values" title="Union type">
					<value title="By keys">keys</value>
					<value title="By values">values</value>
				</attribute>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:UNION generates the union of two arrays by merging the items of an array with those items of the set array that do not exist in the original array, whereas duplicated non-numeric keys are overwritten while items with numeric keys are appended.</description>

			<attention>ARRAY:UNION is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It partially preserves the key and value associations of the array.</attention>

			<example title="Union by keys">
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
					</array>

					<array var="union">
						<item key="sj">Steve Jobs</item>
						<item key="le">Larry Ellison</item>
					</array>

					<array:union var="names" var_set="union" type="keys"/>
					<output>$names.bg and $names.sj are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>

			<example title="Union by values">
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
					</array>

					<array var="union">
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array:union var="names" var_set="union" type="values"/>
					<output>$names[0] and $names[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:replace" title="Replace array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_replacement" type="var" title="Replacement variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:REPLACE replaces the values of an array with the values of a replacement array based on their common keys.</description>

			<attention>ARRAY:REPLACE is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array var="replacement">
						<item key="bg">William Henry Gates III</item>
					</array>

					<array:replace var="names" var_replacement="replacement"/>
					<output>$names.bg and $names.sj are competitors!</output>

					<!-- William Henry Gates III and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:filter" title="Filter array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
				<attribute name="value" type="string|regexp" title="Value to compare to"/>

				<attribute name="func" type="string" default="=" title="Comparison function">
					<value title="Equals">=</value>
					<value title="Equals, case-insensitive">=*</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Not equals, case-insensitive">!=*</value>
					<value title="Not equals, case-insensitive">&lt;&gt;*</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
					<value title="Contains">_</value>
					<value title="Contains, case-insensitive">_*</value>
					<value title="Not contains">!_</value>
					<value title="Not contains, case-insensitive">!_*</value>
					<value title="Starts with">^</value>
					<value title="Starts with, case-insensitive">^*</value>
					<value title="Not starts with">!^</value>
					<value title="Not starts with, case-insensitive">!^*</value>
					<value title="Ends with">$</value>
					<value title="Ends with, case-insensitive">$*</value>
					<value title="Not ends with">!$</value>
					<value title="Not ends with, case-insensitive">!$*</value>
					<value title="Matches regular expression">~</value>
					<value title="Not matches regular expression">!~</value>
				</attribute>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:FILTER filters an array by extracting those items of an array whose values meet the given condition.</description>
			<description>A given key may specify the column of a multidimensional array to filter by. If however, the key is omitted, then the array is treated as an unidimensional list.</description>
			<description>Comparison of numeric values is always performed numerically regardless of the intrinsic data types.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be discarded.</attention>
			<attention>ARRAY:FILTER is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>
		</command>

		<command name="array:trim" title="Strip whitespaces from array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>

				<attribute name="type" type="type" default="both" title="Direction type">
					<value title="From left">left</value>
					<value title="From right">right</value>
					<value title="Both">both</value>
				</attribute>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:TRIM strips whitespace characters from the beginning and/or end of the value of each item of an array.</description>
			<description>A given key may specify the column of a multidimensional array to trim. If however, the key is omitted, then the array is treated as an unidimensional list.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be skipped.</attention>
			<attention>ARRAY:TRIM is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>     Bill Gates     </item>
						<item>     Steve Jobs     </item>
					</array>

					<array:trim var="names"/>
					<output>$names[0]</output>

					<!-- Bill Gates -->
				]]>
			</example>
		</command>

		<command name="array:keys" title="Array keys">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:KEYS extracts all keys of an array.</description>

			<attention>ARRAY:KEYS is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array:keys var="names" var_result="keys"/>
					<output>$keys[0] and $keys[1] are competitors!</output>

					<!-- bg and sj are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:values" title="Array values">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:VALUES extracts all values of an array.</description>
			<description>A given key may specify the column of a multidimensional array to extract from. If however, the key is omitted, then the array is treated as an unidimensional list.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be skipped.</attention>
			<attention>ARRAY:VALUES is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<array:values var="names" var_result="values"/>
					<output>$values[0] and $values[1] are competitors!</output>

					<!-- Bill Gates and Steve Jobs are competitors! -->
				]]>
			</example>
		</command>

		<command name="array:chunk" title="Chunk-split array">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
				<attribute name="length" type="int" default="1" title="Length"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:CHUNK splits an array into chunks of a given length.</description>

			<attention>ARRAY:CHUNK is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>
		</command>

		<command name="array:group" title="Group array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:GROUP groups the items of a multidimensional array by a given key.</description>

			<attention>If the key does not exist within the inner array, the corresponding item of the outer array will be discarded.</attention>
			<attention>ARRAY:GROUP is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>
		</command>

		<command name="array:sort" title="Sort array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" default="(destructive on 'var')" title="Result variable name"/>

				<attribute name="type" type="type" default="asc" title="Sorting type">
					<value title="Ascending">asc</value>
					<value title="Descending">desc</value>
					<value title="Ascending natural">nat-asc</value>
					<value title="Descending natural">nat-desc</value>
					<value title="Ascending by keys">keys-asc</value>
					<value title="Descending by keys">keys-desc</value>
					<value title="Ascending natural by keys">keys-nat-asc</value>
					<value title="Descending natural by keys">keys-nat-desc</value>
					<value title="Random">rand</value>
				</attribute>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var|var_result" type="array" predicate="no-result-propagation"/>

			<description>ARRAY:SORT sorts the items of an array in a particular order, specified by a given sorting type.</description>
			<description>A given key may specify the column of a multidimensional array to sort by. If however, the key is omitted, then the array is treated as an unidimensional list.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be treated as NULL for the purpose of sorting.</attention>
			<attention>ARRAY:SORT is destructive, in the sense that it modifies the array in-place, unless 'var_result' is specified in which case a copy of the resulting array will be stored in 'var_result' instead. It preserves the key and value associations of the array.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<array:sort var="names" type="desc"/>

					<output>
						<array:join var="names" delimiter=", "/>
					</output>

					<!-- Steve Jobs, Larry Ellison, Bill Gates -->
				]]>
			</example>
		</command>

		<command name="array:aggregate" title="Aggregate array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>

				<attribute name="type" type="type" default="count" title="Aggregation type">
					<value title="Count">count</value>
					<value title="Summation">sum</value>
					<value title="Average">avg</value>
					<value title="Product">product</value>
					<value title="Minimum">min</value>
					<value title="Maximum">max</value>
					<value title="Range">range</value>
					<value title="Median">median</value>
					<value title="Arithmetic mean">mean-arith</value>
					<value title="Geometric mean">mean-geo</value>
					<value title="Harmonic mean">mean-harm</value>
					<value title="Square mean">mean-sqr</value>
					<value title="Population standard deviation">stddev-pop</value>
					<value title="Sample standard deviation">stddev-samp</value>
					<value title="Population variance">var-pop</value>
					<value title="Sample variance">var-samp</value>
				</attribute>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var_result">
				<value type="int|float" title="Result"/>
				<value type="null" title="Invalid (min/max/median/mean-harm/stddev-samp/var-samp)">NULL</value>
			</result>

			<description>ARRAY:AGGREGATE calculates an aggregated value of the values of an array based on a given aggregation type.</description>
			<description>A given key may specify the column of a multidimensional array to aggregate by. If however, the key is omitted, then the array is treated as an unidimensional list.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be skipped.</attention>
			<attention>Array items with non-numeric values will be skipped.</attention>

			<example title="Count">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="count"/>
					</output>

					<!-- 6 -->
				]]>
			</example>

			<example title="Summation">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="sum"/>
					</output>

					<!-- 234 -->
				]]>
			</example>

			<example title="Average">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="avg"/>
					</output>

					<!-- 39 -->
				]]>
			</example>

			<example title="Product">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="product"/>
					</output>

					<!-- 1650180096 -->
				]]>
			</example>

			<example title="Minimum">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="min"/>
					</output>

					<!-- 16 -->
				]]>
			</example>

			<example title="Maximum">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="max"/>
					</output>

					<!-- 62 -->
				]]>
			</example>

			<example title="Range">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="range"/>
					</output>

					<!-- 46 -->
				]]>
			</example>

			<example title="Median">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="median"/>
					</output>

					<!-- 40 -->
				]]>
			</example>

			<example title="Arithmetic mean">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="mean-arith"/>
					</output>

					<!-- 39 -->
				]]>
			</example>

			<example title="Geometric mean">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="mean-geo"/>
					</output>

					<!-- 34.375990770947 -->
				]]>
			</example>

			<example title="Harmonic mean">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="mean-harm"/>
					</output>

					<!-- 29.867417906506 -->
				]]>
			</example>

			<example title="Square mean">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="mean-sqr"/>
					</output>

					<!-- 42.891335566367 -->
				]]>
			</example>

			<example title="Population standard deviation">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="stddev-pop"/>
					</output>

					<!-- 17.851237118661 -->
				]]>
			</example>

			<example title="Sample standard deviation">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="stddev-samp"/>
					</output>

					<!-- 19.555050498529 -->
				]]>
			</example>

			<example title="Population variance">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="var-pop"/>
					</output>

					<!-- 318.66666666667 -->
				]]>
			</example>

			<example title="Sample variance">
				<![CDATA[
					<array var="numbers">
						<item>16</item>
						<item>32</item>
						<item>19</item>
						<item>57</item>
						<item>62</item>
						<item>48</item>
					</array>

					<output>
						<array:aggregate var="numbers" type="var-samp"/>
					</output>

					<!-- 382.4 -->
				]]>
			</example>
		</command>

		<command name="array:join" title="Join array items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
				<attribute name="delimiter" type="string" title="Delimiter"/>
			</attributes>

			<attributes title="Multidimensional">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<result binding="var_result" type="string"/>

			<description>ARRAY:JOIN joins the items of an array together to form a string representation with each value separated by a given delimiter.</description>
			<description>A given key may specify the column of a multidimensional array to join by. If however, the key is omitted, then the array is treated as an unidimensional list.</description>

			<attention>If a key is specified and that key does not exist within the inner array, the corresponding item of the outer array will be skipped.</attention>

			<example>
				<![CDATA[
					<array var="names">
						<item>Bill Gates</item>
						<item>Steve Jobs</item>
						<item>Larry Ellison</item>
					</array>

					<output>
						<array:join var="names" delimiter=", "/>
					</output>

					<!-- Bill Gates, Steve Jobs, Larry Ellison -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="encode" title="Encoding">
		<command name="encode:hash" title="Hash">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="algorithm" type="string" default="md5" title="Algorithm"/>
				<attribute name="raw" type="bool" title="Raw binary format"/>
			</attributes>

			<attributes title="HMAC">
				<attribute name="key" type="string" title="Key"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:HASH generates the hash of a value according to a given algorithm.</description>

			<example>
				<![CDATA[
					<output>
						<encode:hash algorithm="sha1" key="ixml">My name is iXML!</encode:hash>
					</output>

					<!-- f66b1452e6c9a6061bb9837a511470e06f23d9b5 -->
				]]>
			</example>
		</command>

		<command name="encode:md5" title="MD5 hash">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:MD5 generates the MD5 hash of a value as a 32-character hexadecimal number using the RSA Data Security, Inc. MD5 Message-Digest Algorithm.</description>

			<example>
				<![CDATA[
					<output>
						<encode:md5>My name is iXML!</encode:md5>
					</output>

					<!-- 5a93f1d56c2f7551b9e3dd90e93fb6c0 -->
				]]>
			</example>
		</command>

		<command name="encode:sha1" title="SHA-1 hash">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:SHA1 generates the SHA-1 hash of a value as a 40-character hexadecimal number using the US Secure Hash Algorithm 1.</description>

			<example>
				<![CDATA[
					<output>
						<encode:sha1>My name is iXML!</encode:sha1>
					</output>

					<!-- bb9b1ff0d612972f6a48652caf6de4201c07c9f6 -->
				]]>
			</example>
		</command>

		<command name="encode:crc32" title="CRC32 checksum">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="int"/>

			<description>ENCODE:CRC32 generates the 32-bit cyclic redundancy checksum polynomial of a value as a signed integer number.</description>

			<example>
				<![CDATA[
					<output>
						<encode:crc32>My name is iXML!</encode:crc32>
					</output>

					<!-- -122920343 -->
				]]>
			</example>
		</command>

		<command name="encode:soundex" title="Soundex key">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:SOUNDEX generates the 4-character soundex key of a value.</description>
			<description>Soundex keys have the property that words pronounced similarly produce the same soundex key.</description>

			<attention>ENCODE:SOUNDEX is less accurate than ENCODE:METAPHONE as the latter knows the basic rules of English pronunciation.</attention>

			<example>
				<![CDATA[
					<output>
						<encode:soundex>iXML</encode:soundex>
					</output>

					<!-- I254 -->
				]]>
			</example>
		</command>

		<command name="encode:metaphone" title="Metaphone key">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:METAPHONE generates the metaphone key of a value.</description>
			<description>Metaphone keys have the property that words pronounced similarly produce the same metaphone key.</description>

			<attention>ENCODE:METAPHONE is more accurate than ENCODE:SOUNDEX as it knows the basic rules of English pronunciation.</attention>

			<example>
				<![CDATA[
					<output>
						<encode:metaphone>iXML</encode:metaphone>
					</output>

					<!-- IKSML -->
				]]>
			</example>
		</command>

		<command name="encode:crypt" title="Symmetric-key encryption">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for ciphertext"/>
				<attribute name="var_iv" type="var" title="Result variable name for initialization vector"/>
				<attribute name="cipher" type="string" title="Cipher"/>
				<attribute name="key" type="string" title="Cryptographic key"/>
			</attributes>

			<content type="string" title="Plaintext"/>
			<result binding="var" type="string"/>

			<description>ENCODE:CRYPT encryptes plaintext with a key according to a given cipher.</description>
			<description>ENCODE:CRYPT is the complement of the DECODE:CRYPT operation.</description>
		</command>

		<command name="encode:deflate" title="DEFLATE compression">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="level" type="int" default="-1" title="Compression level"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:DEFLATE compresses a value to DEFLATE data format according to RFC 1951.</description>
			<description>ENCODE:DEFLATE is the complement of the DECODE:DEFLATE operation.</description>
		</command>

		<command name="encode:zlib" title="ZLIB compression">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="level" type="int" default="-1" title="Compression level"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:ZLIB compresses a value to ZLIB data format according to RFC 1950.</description>
			<description>ENCODE:ZLIB is the complement of the DECODE:ZLIB operation.</description>
		</command>

		<command name="encode:xml" title="Encode XML">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:XML encodes a value by converting special reserved characters to their applicable XML entites.</description>
			<desctiption>'&amp;' (ampersand) becomes '&amp;amp;', '"' (double quote) becomes '&amp;quot;', '&lt;' (less than) becomes '&amp;lt;' and '&gt;' (greater than) becomes '&amp;gt;'.</desctiption>
			<description>ENCODE:XML is the complement of the DECODE:XML operation.</description>

			<attention>The characters mentioned above have special significance in XML, and should be represented by XML entities if they are to preserve their meanings.</attention>

			<example>
				<![CDATA[
					<output>
						<encode:xml>My name is "iXML" &amp; I am a XML derivative!</encode:xml>
					</output>

					<!-- My name is &quot;iXML&quot; &amp; I am a XML derivative! -->
				]]>
			</example>
		</command>

		<command name="encode:html" title="Encode HTML">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:HTML encodes a value by converting special reserved characters to their applicable HTML entites and whitespace characters to a meaningful HTML representation.</description>
			<desctiption>Analogous to ENCODE:XML '&amp;' (ampersand) becomes '&amp;amp;', '"' (double quote) becomes '&amp;quot;', '&lt;' (less than) becomes '&amp;lt;', '&gt;' (greater than) becomes '&amp;gt;'. In addition, new lines become HTML line breaks ('&lt;br /&gt;') and continues whitespace characters become non-breaking spaces ('&amp;nbsp;').</desctiption>
			<description>ENCODE:HTML is compatible to the DECODE:HTML operation, but not the complement thereof.</description>

			<attention>The characters mentioned above have special significance in HTML, and should be represented by HTML entities if they are to preserve their meanings.</attention>

			<example>
				<![CDATA[
					<output>
						<encode:html>Hello World!&n;My name is "iXML" &amp; I am a XML derivative!</encode:html>
					</output>

					<!-- Hello World!<br />My name is &quot;iXML&quot; &amp; I am a XML derivative! -->
				]]>
			</example>
		</command>

		<command name="encode:url" title="Encode URL">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:URL encodes a value according to RFC 1738 by replacing non-alphanumeric characters except '-', '_' and '.' with a percent sign ('%') followed by a 2-character hexadecimal number.</description>
			<description>ENCODE:URL is the complement of the DECODE:URL operation.</description>

			<example>
				<![CDATA[
					<output>
						<encode:url>My name is iXML!</encode:url>
					</output>

					<!-- My%20name%20is%20iXML%21 -->
				]]>
			</example>
		</command>

		<command name="encode:base64" title="Encode MIME Base64">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:BASE64 encodes a value according to RFC 2045 using a 65-character printable subset of US-ASCII to represent arbitrary byte sequences.</description>
			<description>MIME Base64 is designed to make binary data survive transport through transport layers that are not 8-bit clean. MIME Base64-encoded data is about 33 percent larger than the unencoded data.</description>
			<description>ENCODE:BASE64 is the complement of the DECODE:BASE64 operation.</description>

			<example>
				<![CDATA[
					<output>
						<encode:base64>My name is iXML!</encode:base64>
					</output>

					<!-- TXkgbmFtZSBpcyBpWE1MIQ== -->
				]]>
			</example>
		</command>

		<command name="encode:quotedprint" title="Encode quoted-printable">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>ENCODE:QUOTEDPRINT encodes a value according to RFC 2045 by replacing unprintable characters with an equal sign ('=') followed by a 2-character hexadecimal number.</description>
			<description>ENCODE:QUOTEDPRINT is the complement of the DECODE:QUOTEDPRINT operation.</description>

			<example>
				<![CDATA[
					<output>
						<encode:quotedprint>Hello World!&n;My name is iXML!</encode:quotedprint>
					</output>

					<!-- Hello World!=0AMy name is iXML! -->
				]]>
			</example>
		</command>

		<command name="encode:json" title="Encode JSON">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
				<attribute name="pretty" type="bool" title="Pretty print"/>
			</attributes>

			<result binding="var_result" type="string"/>

			<description>ENCODE:JSON generates the JavaScript Object Notation (JSON) representation of the structural value of a variable according to RFC 4627.</description>
			<description>ENCODE:JSON is the complement of the DECODE:JSON operation.</description>

			<example>
				<![CDATA[
					<array var="names">
						<item key="bg">Bill Gates</item>
						<item key="sj">Steve Jobs</item>
					</array>

					<output>
						<encode:json var="names"/>
					</output>

					<!-- {"bg":"Bill Gates","sj":"Steve Jobs"} -->
				]]>
			</example>
		</command>

		<command name="encode:csv" title="Encode CSV">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
				<attribute name="delimiter" type="string" default=";" title="Delimiter"/>
				<attribute name="enclose" type="bool" title="Enclose values"/>
			</attributes>

			<result binding="var_result" type="string"/>

			<description>ENCODE:CSV joins the items of a multidimensional array to comma-separated values.</description>
			<description>Comma-separated values represent tabular data. Each line corresponds to a row in the table. Within a line, fields are separated by a delimiter, each field belonging to one table column.</description>

			<example>
				<![CDATA[
					<array var="names">
						<array>
							<item>First Name</item>
							<item>Last Name</item>
						</array>

						<array>
							<item>Bill</item>
							<item>Gates</item>
						</array>

						<array>
							<item>Steve</item>
							<item>Jobs</item>
						</array>
					</array>

					<output>
						<encode:csv var="names" delimiter=";"/>
					</output>

					<!--
					"First Name";"Last Name"
					Bill;Gates
					Steve;Jobs
					-->
				]]>
			</example>
		</command>

		<command name="encode:binary" title="Pack binary data">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
				<attribute name="format" type="string" title="Format"/>
			</attributes>

			<result binding="var_result" type="string"/>

			<description>ENCODE:BINARY packs the values of an array into binary data according to a given Perl/PHP-compatible format.</description>
			<description>ENCODE:BINARY is the complement of the DECODE:BINARY operation.</description>
		</command>
	</namespace>

	<namespace name="decode" title="Decoding">
		<command name="decode:crypt" title="Symmetric-key decryption">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="cipher" type="string" title="Cipher"/>
				<attribute name="iv" type="string" title="Initialization vector"/>
				<attribute name="key" type="string" title="Cryptographic key"/>
			</attributes>

			<content type="string" title="Ciphertext"/>
			<result binding="var" type="string"/>

			<description>DECODE:CRYPT decryptes ciphertext with a key according to a given cipher.</description>
			<description>DECODE:CRYPT is the complement of the ENCODE:CRYPT operation.</description>
		</command>

		<command name="decode:deflate" title="DEFLATE decompression">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:DEFLATE decompresses a value from DEFLATE data format according to RFC 1951.</description>
			<description>DECODE:DEFLATE is the complement of the ENCODE:DEFLATE operation.</description>
		</command>

		<command name="decode:zlib" title="ZLIB decompression">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:ZLIB decompresses a value from ZLIB data format according to RFC 1950.</description>
			<description>DECODE:ZLIB is the complement of the ENCODE:ZLIB operation.</description>
		</command>

		<command name="decode:xml" title="Decode XML">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:XML decodes a value by converting special XML entites back to their applicable characters.</description>
			<desctiption>'&amp;amp;' becomes '&amp;' (ampersand), '&amp;quot;' becomes '"' (double quote), '&amp;lt;' becomes '&lt;' (less than) and '&amp;gt;' becomes '&gt;' (greater than).</desctiption>
			<description>DECODE:XML is the complement of the ENCODE:XML operation.</description>

			<example>
				<![CDATA[
					<output>
						<decode:xml>My name is &quot;iXML&quot; &amp;amp; I am a XML derivative!</decode:xml>
					</output>

					<!-- My name is "iXML" & I am a XML derivative! -->
				]]>
			</example>
		</command>

		<command name="decode:html" title="Decode HTML">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:HTML decodes a value by stripping HTML tags and converting all HTML entites back to their applicable characters.</description>
			<desctiption>Analogous to DECODE:XML '&amp;amp;' becomes '&amp;' (ampersand), '&amp;quot;' becomes '"' (double quote), '&amp;lt;' becomes '&lt;' (less than) and '&amp;gt;' becomes '&gt;' (greater than). In addition, all other HTML entities are converted back to their applicable characters and HTML line breaks ('&lt;br /&gt;') become new lines.</desctiption>
			<description>DECODE:HTML is compatible to the ENCODE:HTML operation, but it is not the complement thereof.</description>

			<example>
				<![CDATA[
					<output>
						<decode:html>Hello World!&lt;br /&gt;My name is &quot;iXML&quot; &amp;amp; I am a XML derivative!</decode:html>
					</output>

					<!--
					Hello World!
					My name is "iXML" & I am a XML derivative!
					-->
				]]>
			</example>
		</command>

		<command name="decode:url" title="Decode URL">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:URL decodes a value according to RFC 3986 by replacing sequences incipient with a percent sign ('%') followed by a 2-character hexadecimal number with their applicable characters.</description>
			<description>DECODE:URL is the complement of the ENCODE:URL operation.</description>

			<example>
				<![CDATA[
					<output>
						<decode:url>My%20name%20is%20iXML%21</decode:url>
					</output>

					<!-- My name is iXML! -->
				]]>
			</example>
		</command>

		<command name="decode:base64" title="Decode MIME Base64">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:BASE64 decodes a value according to RFC 2045 by converting printable characters back to arbitrary byte sequences.</description>
			<description>MIME Base64 is designed to make binary data survive transport through transport layers that are not 8-bit clean. MIME Base64-encoded data is about 33 percent larger than the unencoded data.</description>
			<description>DECODE:BASE64 is the complement of the ENCODE:BASE64 operation.</description>

			<example>
				<![CDATA[
					<output>
						<decode:base64>TXkgbmFtZSBpcyBpWE1MIQ==</decode:base64>
					</output>

					<!-- My name is iXML! -->
				]]>
			</example>
		</command>

		<command name="decode:quotedprint" title="Decode quoted-printable">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Value"/>
			<result binding="var" type="string"/>

			<description>DECODE:QUOTEDPRINT decodes a value according to RFC 2045 by replacing sequences incipient with an equal sign ('=') followed by a 2-character hexadecimal number with their applicable characters.</description>
			<description>DECODE:QUOTEDPRINT is the complement of the ENCODE:QUOTEDPRINT operation.</description>

			<example>
				<![CDATA[
					<output>
						<decode:quotedprint>Hello World!=0AMy name is iXML!</decode:quotedprint>
					</output>

					<!--
					Hello World!
					My name is iXML!
					-->
				]]>
			</example>
		</command>

		<command name="decode:json" title="Decode JSON">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="JSON value"/>
			<result binding="var"/>

			<description>DECODE:JSON generates a structural value from a JavaScript Object Notation (JSON) representation according to RFC 4627.</description>
			<description>DECODE:JSON is the complement of the ENCODE:JSON operation.</description>

			<example>
				<![CDATA[
					<decode:json var="names">{"bg":"Bill Gates","sj":"Steve Jobs"}</decode:json>
					<output>$names.bg</output>
					<!-- Bill Gates -->
				]]>
			</example>
		</command>

		<command name="decode:csv" title="Decode CSV">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="delimiter" type="string" default=";" title="Delimiter (single ASCII character)"/>
			</attributes>

			<content type="string" title="Comma-separated values"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>DECODE:CSV parses comma-separated values into a multidimensional array.</description>
			<description>Comma-separated values represent tabular data. Each line corresponds to a row in the table. Within a line, fields are separated by a delimiter, each field belonging to one table column.</description>
		</command>

		<command name="decode:binary" title="Unpack binary data">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="format" type="string" title="Format"/>
			</attributes>

			<content type="string" title="Binary data"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>DECODE:BINARY unpacks binary data into an array according to a given Perl/PHP-compatible format.</description>
			<description>DECODE:BINARY is the complement of the ENCODE:BINARY operation.</description>
		</command>
	</namespace>

	<namespace name="xml" title="XML">
		<command name="xml:create" title="Create XML">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var_result" type="string"/>

			<description>XML:CREATE generates a XML document according to the XML 1.0 Specification.</description>
			<description>
				The given variable references the root element and must be an array comprised of the following items:

				Key   Description
				--------------------------------------------------------------
				name  tag name
				attr  array of attributes with associated name and value pairs
				nodes array of child nodes including cdata parts
				cdata cdata value (optionally instead of 'nodes')
			</description>

			<example>
				<![CDATA[
					<array var="root">
						<item key="name">html</item>

						<array key="attr">
							<item key="xmlns">http://www.w3.org/1999/xhtml</item>
							<item key="xml:lang">en</item>
						</array>
					</array>

					<output>
						<xml:create var="root"/>
					</output>

					<!--
					<?xml version="1.0" encoding="UTF-8"?>
					<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"/>
					-->
				]]>
			</example>
		</command>

		<command name="xml:parse" title="Parse XML">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="XML document"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>XML:PARSE parses a XML document.</description>
			<description>
				XML:PARSE returns the root element as an array comprised of the following items:

				Key   Description
				---------------------------------------------------------------------------
				name  tag name (upper case)
				attr  array of attributes with associated name (upper case) and value pairs
				nodes array of child nodes including cdata parts
				child array of child elements
				elems array of child elements grouped by tag name (upper case)
				cdata concatenated cdata value
			</description>
		</command>
	</namespace>

	<namespace name="soap" title="SOAP">
		<command name="soap:client" title="SOAP client">
			<attributes>
				<attribute name="wsdl" type="string" title="WSDL filename/URL"/>
			</attributes>

			<content type="ixml"/>

			<description>SOAP:CLIENT defines a set of dynamically bound SOAP operations based on SOAP 1.1 according to a given WSDL model.</description>

			<example>
				<![CDATA[
					<soap:client wsdl="http://www.dneonline.com/calculator.asmx?WSDL">
						<soap:bind var="add">add</soap:bind>
					</soap:client>

					<array var="parameters">
						<item key="intA">2</item>
						<item key="intB">5</item>
					</array>

					<call func="add" var="result">
						<param var="parameters"/>
					</call>

					<output>$result.AddResult</output>

					<!-- 7 -->
				]]>
			</example>
		</command>

		<command name="soap:bind" title="SOAP binding">
			<parents>
				<parent>soap:client</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Function variable name"/>
			</attributes>

			<content type="string" title="Operation"/>
			<result binding="var" type="function" predicate="no-result-propagation"/>

			<description>SOAP:BIND defines a SOAP operation as a function that can be invoked with subsequent CALL statements.</description>
		</command>
	</namespace>

	<namespace name="rest" title="RESTful">
		<command name="rest:client" title="RESTful client">
			<attributes>
				<attribute name="timeout" type="int" default="30" title="Timeout in seconds"/>
				<attribute name="url" type="string" title="URL"/>
				<attribute name="validate" type="bool" title="Validate SSL"/>
			</attributes>

			<children>
				<child name="rest:header" title="REST header" occurrence="single">
					<content type="string" title="Request header"/>
				</child>
			</children>

			<content type="ixml"/>

			<description>REST:CLIENT defines a set of dynamically bound RESTful resources based on HTTP/1.1.</description>

			<example>
				<![CDATA[
					<rest:client url="https://api.predic8.de/shop">
						<rest:header>
							Content-Type: application/json
						</rest:header>

						<rest:bind var="createProduct" method="POST">/products/</rest:bind>
						<rest:bind var="updateProduct" method="PATCH">/products/:id</rest:bind>
						<rest:bind var="getProduct" method="GET">/products/:id</rest:bind>
					</rest:client>

					<decode:json var="data">
						<call func="createProduct">
							<param>{"name": "Some Fruit", "price": 4.99}</param>
						</call>
					</decode:json>

					<match var_matches="matches" pattern="/\d+/">$data.product_url</match>
					<set var="id">$matches[0][0]</set>

					<call func="updateProduct">
						<param var="id"/>
						<param>{"name": "Wildberries"}</param>
					</call>

					<decode:json var="data">
						<call func="getProduct">
							<param var="id"/>
						</call>
					</decode:json>

					<output>$data.name</output>

					<!-- Wildberries -->
				]]>
			</example>
		</command>

		<command name="rest:bind" title="RESTful binding">
			<parents>
				<parent>rest:client</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Function variable name"/>

				<attribute name="method" type="string" default="GET" title="Method">
					<value title="HEAD">HEAD</value>
					<value title="GET">GET</value>
					<value title="POST">POST</value>
					<value title="PUT">PUT</value>
					<value title="PATCH">PATCH</value>
					<value title="DELETE">DELETE</value>
					<value title="TRACE">TRACE</value>
					<value title="OPTIONS">OPTIONS</value>
					<value title="CONNECT">CONNECT</value>
				</attribute>

				<attribute name="type" type="type" default="prepared" title="Processing type">
					<value title="Raw">raw</value>
					<value title="Prepared">prepared</value>
				</attribute>
			</attributes>

			<content type="string" title="Route"/>
			<result binding="var" type="function" predicate="no-result-propagation"/>

			<description>REST:BIND defines a RESTful resource as a function that can be invoked with subsequent CALL statements.</description>
			<description>Resource route arguments of the form ':name' are substituted with the actual corresponding parameter values when being called. All remaining parameters are treated as query arguments according to RFC 3986 and are generally passed via the URL query component except for method POST in which case they are transported as the HTTP body.</description>
			<description>
				Invoked resources return an array comprised of the following items if type is specified as 'raw':

				Key    Description
				----------------------------
				status response status code
				type   response content type
				header response header
				body   response body
			</description>
		</command>

		<command name="rest:server" title="RESTful server">
			<children>
				<child name="rest:resource" title="RESTful resource definition" occurrence="multiple">
					<attributes>
						<attribute name="var_header" type="var" title="Result variable name for request header"/>
						<attribute name="var_body" type="var" title="Result variable name for request body"/>
						<attribute name="route" type="string" title="Route"/>

						<attribute name="method" type="string" default="GET" title="Method">
							<value title="HEAD">HEAD</value>
							<value title="GET">GET</value>
							<value title="POST">POST</value>
							<value title="PUT">PUT</value>
							<value title="PATCH">PATCH</value>
							<value title="DELETE">DELETE</value>
							<value title="TRACE">TRACE</value>
							<value title="OPTIONS">OPTIONS</value>
							<value title="CONNECT">CONNECT</value>
						</attribute>
					</attributes>

					<children>
						<child name="use" title="Use" occurrence="multiple">
							<attributes>
								<attribute name="name" type="string" default="(same as last member of 'var')" title="Name"/>
								<attribute name="var" type="var" title="Variable name"/>
							</attributes>
						</child>
					</children>

					<content type="ixml"/>
				</child>
			</children>

			<description>The REST:SERVER construct is a control flow structure that allows for selective execution of code according to the underlying RESTful request based on HTTP, in which each resource is a special type of subroutine.</description>
			<description>REST:SERVER will invoke the resource subroutine of the first route that matches the current HTTP request's path and method with the associated request header field name and value pairs assigned to 'var_header' and the request body assigned to 'var_body'. Also, resource route arguments of the form ':name' as well as query arguments are assigned to corresponding local variables. The route may contain a final variadic argument of the form '*name' for all remaining route components as an array.</description>
			<description>The USE construct declares a free function variable for use as a local variable within the resource subroutine that is explicitly bound to a corresponding variable from the immediate context within which the RESTful server is defined, thereby directly referencing the non-local variable from the parent scope outside of the inherent context of the resource subroutine.</description>

			<attention>Within a REST:SERVER statement all output is buffered so that header fields can be sent after output has already been initiated, though actual output must not be sent before that REST:SERVER statement.</attention>
			<attention>The resource subroutine incorporates a local context when being called. Therefore local variables may be declared within the resource subroutine.</attention>
			<attention>The special local variable 'return' is a reference to the return value that may be passed back as as the HTTP status code to the client.</attention>
			<attention>The special local variable 'arguments' is a reference to all arguments that have been passed to local variables on switch of context.</attention>
			<attention>The RETURN, BREAK and NEXT operations may be used to break-off the execution of the resource subroutine, thereby implicitly returning to the original control flow of the invoking control statement.</attention>

			<example>
				<![CDATA[
					<global var="people"/>

					<array var="people">
						<array key="bg">
							<item key="lastname">Gates</item>
							<item key="firstname">Bill</item>
						</array>

						<array key="sj">
							<item key="lastname">Jobs</item>
							<item key="firstname">Steve</item>
						</array>
					</array>

					<rest:server>
						<rest:resource route="/person/:id" method="GET">
							<array:keyexists var="people" var_result="exists">$id</array:keyexists>

							<is var="exists" type="false">
								<set var="return">404</set>
								<return/>
							</is>

							<header>Content-Type: application/json</header>

							<output>
								<encode:json var="people[$id]"/>
							</output>
						</rest:resource>

						<rest:resource route="/person/:id" method="POST">
							<set var="people[$id].lastname">$lastname</set>
							<set var="people[$id].firstname">$firstname</set>
						</rest:resource>

						<rest:resource route="/person/:id" method="PUT" var_body="data">
							<decode:json var="people[$id]">$data</decode:json>
							<set var="return">201</set>
						</rest:resource>

						<rest:resource route="/person/:id" method="DELETE">
							<unset var="people[$id]"/>
						</rest:resource>
					</rest:server>
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="http" title="HTTP">
		<command name="http:request" title="HTTP request">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for response body"/>
				<attribute name="var_info" type="var" title="Result variable name for detailed response information"/>
				<attribute name="timeout" type="int" default="30" title="Timeout in seconds"/>
				<attribute name="url" type="string" title="URL"/>
				<attribute name="validate" type="bool" title="Validate SSL"/>

				<attribute name="method" type="string" default="GET" title="Method">
					<value title="HEAD">HEAD</value>
					<value title="GET">GET</value>
					<value title="POST">POST</value>
					<value title="PUT">PUT</value>
					<value title="DELETE">DELETE</value>
					<value title="TRACE">TRACE</value>
					<value title="OPTIONS">OPTIONS</value>
					<value title="CONNECT">CONNECT</value>
				</attribute>
			</attributes>

			<children>
				<child name="http:header" title="HTTP header" occurrence="single">
					<content type="string" title="Request header"/>
				</child>

				<child name="http:body" title="HTTP body" occurrence="single">
					<content type="string" title="Request body"/>
				</child>
			</children>

			<result binding="var" type="string"/>
			<result binding="var_info" type="array" predicate="no-result-propagation"/>

			<description>HTTP:REQUEST sends a HTTP/1.1 request and receives a HTTP response according to RFC 2616.</description>
			<description>
				HTTP:REQUEST returns an array in 'var_info' comprised of the following items:

				Key    Description
				----------------------------
				status response status code
				type   response content type
				header response header
				body   response body
			</description>

			<attention>The Content-Length header field defaults to the size of the HTTP body. The Content-Type header field defaults to application/x-www-form-urlencoded only for method POST.</attention>

			<example>
				<![CDATA[
					<decode:json var="data">
						<http:request url="https://api.predic8.de/shop/products/" method="POST">
							<http:header>
								Content-Type: application/json
							</http:header>

							<http:body>
								{"name": "Wildberries", "price": 4.99}
							</http:body>
						</http:request>
					</decode:json>

					<set var="route">$data.product_url</set>

					<decode:json var="data">
						<http:request url="https://api.predic8.de$route" method="GET"/>
					</decode:json>

					<output>$data.name</output>

					<!-- Wildberries -->
				]]>
			</example>
		</command>

		<command name="http:urlinfo" title="URL information">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="url" type="string" title="URL"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>HTTP:URLINFO parses a URL according to RFC 1738 and returns the various components thereof.</description>
			<description>
				HTTP:URLINFO returns an array comprised of the following items:

				Key      Description
				----------------------------------------------------------------------
				scheme   scheme
				host     hostname
				port     port
				pass     password
				user     username
				path     path
				query    query
				fragment fragment/anchor
				args     array of query arguments with associated name and value pairs
			</description>

			<example>
				<![CDATA[
					<http:urlinfo var="info" url="http://www.google.com?q=iXML"/>
					<output>Scheme: $info.scheme, Host: $info.host, Query: $info.query, Arg 'q': $info.args.q</output>
					<!-- Scheme: http, Host: www.google.com, Query: q=iXML, Arg 'q': iXML -->
				]]>
			</example>
		</command>

		<command name="http:query" title="Build URL query">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
				<attribute name="var_result" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>HTTP:QUERY builds a URL query component out of an array of associated name and value pairs according to RFC 3986.</description>

			<example>
				<![CDATA[
					<array var="args">
						<item key="q">iXML</item>
					</array>

					<output>
						<http:query var="args"/>
					</output>

					<!-- q=iXML -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="file" title="File system">
		<command name="file:pathinfo" title="Path information">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>FILE:PATHINFO parses a filename and returns the various components thereof.</description>
			<description>
				FILE:PATHINFO returns an array comprised of the following items:

				Key       Description
				------------------------------------
				dirname   directory name
				basename  base name
				extension file extension
				filename  filename without extension
			</description>

			<example>
				<![CDATA[
					<file:pathinfo var="info" filename="./test/ixml.inc"/>
					<output>Dir: $info.dirname, Base: $info.basename, Ext: $info.extension, Name: $info.filename</output>
					<!-- Dir: ./test, Base: ixml.inc, Ext: inc, Name: ixml -->
				]]>
			</example>
		</command>

		<command name="file:exists" title="File exists">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename/URL"/>
			</attributes>

			<result binding="var">
				<value type="string" title="Canonicalized filename"/>
				<value type="bool" title="Not exists">FALSE</value>
			</result>

			<description>FILE:EXISTS checks whether a file or directory exists and returns the canonicalized absolute filename if applicable.</description>

			<example>
				<![CDATA[
					<file:exists var="exists" filename="./test/ixml_non_existing.inc"/>

					<is var="exists" type="false">
						<output>File does not exist!</output>
					</is>

					<!-- File does not exist! -->
				]]>
			</example>
		</command>

		<command name="file:typeof" title="Type of file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<result binding="var" type="string">
				<value title="Undefined">undefined</value>
				<value title="Is a regular file">file</value>
				<value title="Is a directory">dir</value>
				<value title="Is a symbolic link">link</value>
			</result>

			<description>FILE:TYPEOF returns the type of a file or directory.</description>

			<example>
				<![CDATA[
					<file:write filename="./test/ixml.inc">iXML</file:write>

					<file:typeof var="type" filename="./test/ixml.inc"/>

					<if value1="$type" func="=" value2="file">
						<output>Filename refers to a regular file!</output>
					</if>

					<!-- Filename refers to a regular file! -->
				]]>
			</example>
		</command>

		<command name="file:status" title="File status">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename"/>
				<attribute name="follow" type="bool" title="Follow symbolic links"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>FILE:STATUS returns the status of a file or directory.</description>
			<description>
				FILE:STATUS returns an array comprised of the following items:

				Index/Key  Description
				-----------------------------------------------------
				0/dev      device number
				1/ino      inode number
				2/mode     inode protection mode
				3/nlink    number of links
				4/uid      userid of owner
				5/gid      groupid of owner
				6/rdev     device type if inode device
				7/size     size in bytes
				8/atime    time of last access (Unix timestamp)
				9/mtime    time of last modification (Unix timestamp)
				10/ctime   time of last inode change (Unix timestamp)
				11/blksize blocksize of filesystem IO
				12/blocks  number of 512-byte blocks allocated
			</description>

			<example>
				<![CDATA[
					<file:status var="status" filename="./test/ixml.inc"/>
					<output>$status.size</output>
					<!-- 4 -->
				]]>
			</example>
		</command>

		<command name="file:read" title="Read file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename/URL"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>FILE:READ reads the entire content of a file.</description>
			<description>FILE:READ is the complement of the FILE:WRITE operation.</description>

			<example>
				<![CDATA[
					<file:write filename="./test/ixml.inc">iXML</file:write>

					<output>
						<file:read filename="./test/ixml.inc"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="file:write" title="Write file">
			<attributes>
				<attribute name="filename" type="string" title="Filename/URL"/>
			</attributes>

			<content type="string" title="Content"/>

			<description>FILE:WRITE writes content to a file.</description>
			<description>If the file does not exist, it will implicitly be created. Otherwise, the existing file is overwritten.</description>
			<description>FILE:WRITE is the complement of the FILE:READ operation.</description>

			<example>
				<![CDATA[
					<file:write filename="./test/ixml.inc">iXML</file:write>

					<output>
						<file:read filename="./test/ixml.inc"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="file:append" title="Append file">
			<attributes>
				<attribute name="filename" type="string" title="Filename/URL"/>
			</attributes>

			<content type="string" title="Content"/>

			<description>FILE:APPEND appends content to a file.</description>
			<description>If the file does not exist, it will implicitly be created.</description>

			<example>
				<![CDATA[
					<file:write filename="./test/ixml.inc">i</file:write>
					<file:append filename="./test/ixml.inc">XML</file:append>

					<output>
						<file:read filename="./test/ixml.inc"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="file:delete" title="Delete file">
			<attributes>
				<attribute name="filename" type="string" title="Filename/URL"/>
			</attributes>

			<description>FILE:DELETE deletes a file.</description>

			<example>
				<![CDATA[
					<file:delete filename="./test/ixml.inc"/>
				]]>
			</example>
		</command>

		<command name="file:rename" title="Rename file">
			<attributes>
				<attribute name="oldname" type="string" title="Old filename/URL"/>
				<attribute name="newname" type="string" title="New filename/URL"/>
			</attributes>

			<description>FILE:RENAME renames/moves a file or directory from an old filename to a new filename.</description>

			<example>
				<![CDATA[
					<file:write filename="./test/ixml_old.inc">iXML</file:write>

					<file:rename oldname="./test/ixml_old.inc" newname="./test/ixml.inc"/>
				]]>
			</example>
		</command>

		<command name="file:link" title="Create symbolic link">
			<attributes>
				<attribute name="linkname" type="string" title="Link name"/>
				<attribute name="targetname" type="string" title="Target name"/>
			</attributes>

			<description>FILE:LINK creates a symbolic link to a target name.</description>

			<example>
				<![CDATA[
					<file:exists var="exists" filename="./test/ixml_link.inc"/>

					<if value1="$exists" func="!=" value2="">
						<file:delete filename="./test/ixml_link.inc"/>
					</if>

					<file:link linkname="./test/ixml_link.inc" targetname="./test/ixml.inc"/>
				]]>
			</example>
		</command>

		<command name="file:listdir" title="List directory">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="dirname" type="string" title="Directory name/URL"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>FILE:LISTDIR lists the filenames of all files within a directory.</description>

			<example>
				<![CDATA[
					<file:listdir var="files" dirname="./test"/>

					<foreach var="files" var_value="filename">
						<if value1="$filename" func="$" value2=".inc">
							<output>$filename&n;</output>
						</if>
					</foreach>

					<!--
					ixml.inc
					ixml_link.inc
					-->
				]]>
			</example>
		</command>

		<command name="file:makedir" title="Make directory">
			<attributes>
				<attribute name="dirname" type="string" title="Directory name/URL"/>
			</attributes>

			<description>FILE:MAKEDIR makes a new directory.</description>
			<description>The directory path is created recursively as paternal directories are implicitly created if they do not yet exist.</description>

			<example>
				<![CDATA[
					<file:makedir dirname="./test/ixml_dir"/>
				]]>
			</example>
		</command>

		<command name="file:removedir" title="Remove directory">
			<attributes>
				<attribute name="dirname" type="string" title="Directory name/URL"/>
			</attributes>

			<description>FILE:REMOVEDIR removes an empty directory.</description>

			<example>
				<![CDATA[
					<file:removedir dirname="./test/ixml_dir"/>
				]]>
			</example>
		</command>

		<command name="file:glob" title="Pathname pattern expansion">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="pattern" type="string" title="Pattern"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>FILE:GLOB finds all pathnames matching a given pattern based on wildcard characters ('?', '*' and '[...]').</description>

			<example>
				<![CDATA[
					<file:glob var="files" pattern="./test/*.inc"/>

					<foreach var="files" var_value="filename">
						<output>$filename&n;</output>
					</foreach>

					<!--
					./test/ixml.inc
					./test/ixml_link.inc
					-->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="zip" title="ZIP">
		<command name="zip:archive" title="Archive">
			<attributes>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<description>ZIP:ARCHIVE creates or opens an existing archive for reading and writing.</description>
		</command>

		<command name="zip:exists" title="Exists entry">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<result binding="var" type="bool"/>

			<description>ZIP:EXISTS checks whether an entry exists within an archive.</description>
		</command>

		<command name="zip:status" title="Entry status">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<result binding="var" predicate="no-result-propagation">
				<value type="array"/>
				<value type="null" title="Not exists">NULL</value>
			</result>

			<description>ZIP:STATUS returns the status of an entry within an archive.</description>
			<description>
				ZIP:STATUS returns an array comprised of the following items:

				Key         Description
				--------------------------------------------------------
				name        filename
				index       index
				crc         32-bit cyclic redundancy checksum polynomial
				size        size in bytes
				mtime       time of last modification (Unix timestamp)
				comp_size   compressed size in bytes
				comp_method compression method
			</description>
		</command>

		<command name="zip:read" title="Read entry">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>ZIP:READ reads the entire content of an entry within an archive.</description>
			<description>ZIP:READ is the complement of the ZIP:WRITE operation.</description>
		</command>

		<command name="zip:write" title="Write entry">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<content type="string" title="Content"/>

			<description>ZIP:WRITE writes content to an entry within an archive.</description>
			<description>If the entry does not exist within the archive, it will implicitly be created. Otherwise, the existing entry is overwritten.</description>
			<description>ZIP:WRITE is the complement of the ZIP:READ operation.</description>
		</command>

		<command name="zip:delete" title="Delete entry">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="filename" type="string" title="Filename"/>
			</attributes>

			<description>ZIP:DELETE deletes an entry within an archive.</description>
		</command>

		<command name="zip:rename" title="Rename entry">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="oldname" type="string" title="Old filename"/>
				<attribute name="newname" type="string" title="New filename"/>
			</attributes>

			<description>ZIP:RENAME renames an entry within an archive from an old filename to a new filename.</description>
		</command>

		<command name="zip:list" title="List entries">
			<parents>
				<parent>zip:archive</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>ZIP:LIST lists the filenames of all entries within an archive.</description>
		</command>
	</namespace>

	<namespace name="db" title="Database">
		<command name="db:connection" title="Connection">
			<attributes>
				<attribute name="server" type="string" title="Server"/>
				<attribute name="dbname" type="string" title="Database name"/>
				<attribute name="username" type="string" title="Username"/>
				<attribute name="password" type="string" title="Password"/>

				<attribute name="type" type="type" default="pgsql" title="Database type">
					<value title="MySQL">mysql</value>
					<value title="PostgreSQL">pgsql</value>
				</attribute>
			</attributes>

			<content type="ixml"/>

			<description>DB:CONNECTION establishes a database connection.</description>
		</command>

		<command name="db:get" title="Get record (ZeyOS)">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_fields" type="var" title="Variable name for field list"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>DB:GET gets a database record, specified by an entity and an ID.</description>

			<example title="Get record">
				<!-- ignore -->
				<![CDATA[
					<db:get var="obj" entity="contacts" id="123"/>
					<output>$obj.firstname $obj.lastname</output>
					<!-- Bill Gates -->
				]]>
			</example>

			<example title="Get and set record">
				<!-- ignore -->
				<![CDATA[
					<db:get var="obj" entity="contacts" id="123">
						<db:field>lastname</db:field>
					</db:get>

					<if value1="$obj.lastname" func="=" value2="Gates">
						<set var="obj.lastname">Jobs</set>
						<set var="obj.firstname">Steve</set>
					</if>

					<db:set entity="contacts" id="123" var_data="obj"/>
				]]>
			</example>
		</command>

		<command name="db:field" title="Field">
			<parents>
				<parent>db:get</parent>
				<parent>db:fields</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
			</attributes>

			<content type="string" title="Field name"/>
		</command>

		<command name="db:expression" title="Expression">
			<parents>
				<parent>db:get</parent>
				<parent>db:fields</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
			</attributes>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:set" title="Set record (ZeyOS)">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name for insert ID"/>
				<attribute name="var_data" type="var" title="Variable name for associated field name and value pairs"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" default="(new)" title="ID"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="int"/>

			<description>DB:SET sets a database record, specified by an entity and an ID.</description>

			<example title="Insert record">
				<!-- ignore -->
				<![CDATA[
					<db:set entity="contacts">
						<db:data field="lastname">Gates</db:data>
						<db:data field="firstname">Bill</db:data>
					</db:set>
				]]>
			</example>

			<example title="Update record">
				<!-- ignore -->
				<![CDATA[
					<db:set entity="contacts" id="123">
						<db:data field="lastname">Jobs</db:data>
						<db:data field="firstname">Steve</db:data>
					</db:set>
				]]>
			</example>

			<example title="Get and set record">
				<!-- ignore -->
				<![CDATA[
					<db:get var="obj" entity="contacts" id="123">
						<db:field>lastname</db:field>
					</db:get>

					<if value1="$obj.lastname" func="=" value2="Gates">
						<set var="obj.lastname">Jobs</set>
						<set var="obj.firstname">Steve</set>
					</if>

					<db:set entity="contacts" id="123" var_data="obj"/>
				]]>
			</example>
		</command>

		<command name="db:data" title="Data">
			<parents>
				<parent>db:get</parent>
				<parent>db:set</parent>
				<parent>db:fields</parent>
				<parent>db:insert</parent>
				<parent>db:update</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>
				<attribute name="alias" type="string" title="Alias name"/>
			</attributes>

			<content type="string" title="Value"/>
		</command>

		<command name="db:null" title="NULL">
			<parents>
				<parent>db:get</parent>
				<parent>db:set</parent>
				<parent>db:fields</parent>
				<parent>db:insert</parent>
				<parent>db:update</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>
				<attribute name="alias" type="string" title="Alias name"/>
			</attributes>
		</command>

		<command name="db:remove" title="Remove record (ZeyOS)">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<description>DB:REMOVE removes a database record, specified by an entity and an ID.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<db:remove entity="contacts" id="123"/>
				]]>
			</example>
		</command>

		<command name="db:lookup" title="Lookup record (ZeyOS)">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="entity" type="string" title="Entity"/>
			</attributes>

			<content type="ixml"/>

			<result binding="var">
				<value type="int" title="ID"/>
				<value type="null" title="Not found">NULL</value>
			</result>

			<description>DB:LOOKUP looks up a database record and returns it's ID if applicable.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<db:lookup entity="contacts" var="id">
						<db:is field="lastname">Gates</db:is>
						<db:is field="firstname">Bill</db:is>
					</db:lookup>

					<if value1="$id" func="=" value2="">
						<output>Contact not found!</output>
					</if>

					<!-- Contact not found! -->
				]]>
			</example>
		</command>

		<command name="db:select" title="Select records">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name for generated SQL statement"/>
				<attribute name="var_count" type="var" title="Result variable name for number of potential records"/>
				<attribute name="var_result" type="var" title="Result variable name for retrieved result set"/>

				<attribute name="type" type="type" default="num" title="Result set type">
					<value title="Multidimensional array with consecutive numeric keys">num</value>
					<value title="Multidimensional array with field names as keys">assoc</value>
					<value title="Unidimensional list">list</value>
					<value title="Unidimensional array with associated attribute and value pairs">av</value>
					<value title="Single array item with consecutive numeric keys">single</value>
					<value title="Single array item with field names as keys">self</value>
					<value title="Single value">value</value>
				</attribute>

				<attribute name="distinct" type="bool" title="Distinct result set"/>
				<attribute name="limit" type="int" default="(no limit)" title="Limit"/>
				<attribute name="offset" type="int" title="Offset"/>
			</attributes>

			<children>
				<child name="db:fields" title="Fields" occurrence="single">
					<attributes>
						<attribute name="var" type="var" title="Variable name for field list"/>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="db:table" title="Table" occurrence="single">
					<attributes>
						<attribute name="alias" type="string" title="Alias name"/>
					</attributes>

					<content type="string" title="Table name"/>
				</child>

				<child name="db:join" title="Join clause" occurrence="single">
					<content type="ixml"/>
				</child>

				<child name="db:groupby" title="Group by clause" occurrence="single">
					<attributes>
						<attribute name="var" type="var" title="Variable name for group by field list"/>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="db:having" title="Having condition" occurrence="single">
					<content type="ixml"/>
				</child>

				<child name="db:orderby" title="Order by clause" occurrence="single">
					<attributes>
						<attribute name="var" type="var" title="Variable name for associated order by field name and type pairs"/>
					</attributes>

					<content type="ixml"/>
				</child>
			</children>

			<content type="ixml"/>
			<result binding="var" type="string"/>
			<result binding="var_count" type="int" predicate="no-result-propagation"/>
			<result binding="var_result" type="array" predicate="no-result-propagation"/>

			<description>DB:SELECT generates and executes a SQL select statement and retrieves the accordant result set of records from the database.</description>
		</command>

		<command name="db:cross" title="Cross join">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="table" type="string" title="Table name"/>
			</attributes>
		</command>

		<command name="db:crosslateral" title="Lateral cross join">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
			</attributes>

			<content type="ixml"/>
		</command>

		<command name="db:inner" title="Inner join">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="table" type="string" title="Table name"/>
			</attributes>

			<attributes title="On condition">
				<attribute name="field1" type="string" title="Field name to compare from"/>
				<attribute name="field2" type="string" title="Field name to compare to"/>

				<attribute name="func" type="string" default="=" title="Comparison operator">
					<value title="Equals">=</value>
					<value title="Equals, case-insensitive">=*</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Not equals, case-insensitive">!=*</value>
					<value title="Not equals, case-insensitive">&lt;&gt;*</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
					<value title="Contains">_</value>
					<value title="Contains, case-insensitive">_*</value>
					<value title="Not contains">!_</value>
					<value title="Not contains, case-insensitive">!_*</value>
					<value title="Starts with">^</value>
					<value title="Starts with, case-insensitive">^*</value>
					<value title="Not starts with">!^</value>
					<value title="Not starts with, case-insensitive">!^*</value>
					<value title="Ends with">$</value>
					<value title="Ends with, case-insensitive">$*</value>
					<value title="Not ends with">!$</value>
					<value title="Not ends with, case-insensitive">!$*</value>
					<value title="Matches regular expression">~</value>
					<value title="Matches regular expression, case-insensitive">~*</value>
					<value title="Not matches regular expression">!~</value>
					<value title="Not matches regular expression, case-insensitive">!~*</value>
					<value title="Is like">L</value>
					<value title="Is like, case-insensitive">L*</value>
					<value title="Is not like">!L</value>
					<value title="Is not like, case-insensitive">!L*</value>
				</attribute>
			</attributes>

			<content type="ixml"/>
		</command>

		<command name="db:innerextdata" title="Inner join on ExtData (ZeyOS)">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="entity" type="string" title="Entity name"/>
				<attribute name="name" type="string" title="ExtData name"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:innertags" title="Inner join on tags (ZeyOS)">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="entity" type="string" title="Entity name"/>
				<attribute name="name" type="string" title="Tag name"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:left" title="Outer left join">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="table" type="string" title="Table name"/>
			</attributes>

			<attributes title="On condition">
				<attribute name="field1" type="string" title="Field name to compare from"/>
				<attribute name="field2" type="string" title="Field name to compare to"/>

				<attribute name="func" type="string" default="=" title="Comparison operator">
					<value title="Equals">=</value>
					<value title="Equals, case-insensitive">=*</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Not equals, case-insensitive">!=*</value>
					<value title="Not equals, case-insensitive">&lt;&gt;*</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
					<value title="Contains">_</value>
					<value title="Contains, case-insensitive">_*</value>
					<value title="Not contains">!_</value>
					<value title="Not contains, case-insensitive">!_*</value>
					<value title="Starts with">^</value>
					<value title="Starts with, case-insensitive">^*</value>
					<value title="Not starts with">!^</value>
					<value title="Not starts with, case-insensitive">!^*</value>
					<value title="Ends with">$</value>
					<value title="Ends with, case-insensitive">$*</value>
					<value title="Not ends with">!$</value>
					<value title="Not ends with, case-insensitive">!$*</value>
					<value title="Matches regular expression">~</value>
					<value title="Matches regular expression, case-insensitive">~*</value>
					<value title="Not matches regular expression">!~</value>
					<value title="Not matches regular expression, case-insensitive">!~*</value>
					<value title="Is like">L</value>
					<value title="Is like, case-insensitive">L*</value>
					<value title="Is not like">!L</value>
					<value title="Is not like, case-insensitive">!L*</value>
				</attribute>
			</attributes>

			<content type="ixml"/>
		</command>

		<command name="db:leftlateral" title="Lateral left join">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
			</attributes>

			<content type="ixml"/>
		</command>

		<command name="db:leftextdata" title="Outer left join on ExtData (ZeyOS)">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="entity" type="string" title="Entity name"/>
				<attribute name="name" type="string" title="ExtData name"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:lefttags" title="Outer left join on tags (ZeyOS)">
			<parents>
				<parent>db:join</parent>
			</parents>

			<attributes>
				<attribute name="alias" type="string" title="Alias name"/>
				<attribute name="entity" type="string" title="Entity name"/>
				<attribute name="name" type="string" title="Tag name"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:groupfield" title="Group by field">
			<parents>
				<parent>db:groupby</parent>
			</parents>

			<content type="string" title="Field name"/>
		</command>

		<command name="db:orderfield" title="Order by field">
			<parents>
				<parent>db:orderby</parent>
			</parents>

			<attributes>
				<attribute name="type" type="type" default="asc" title="Sorting type">
					<value title="Ascending">asc</value>
					<value title="Descending">desc</value>
				</attribute>
			</attributes>

			<content type="string" title="Field name"/>
		</command>

		<command name="db:and" title="And condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<content type="ixml"/>
		</command>

		<command name="db:or" title="Or condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<content type="ixml"/>
		</command>

		<command name="db:not" title="Not condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<content type="ixml"/>
		</command>

		<command name="db:is" title="Is condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="func" type="string" default="=" title="Comparison function">
					<value title="Equals">=</value>
					<value title="Equals, case-insensitive">=*</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Not equals, case-insensitive">!=*</value>
					<value title="Not equals, case-insensitive">&lt;&gt;*</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
					<value title="Contains">_</value>
					<value title="Contains, case-insensitive">_*</value>
					<value title="Not contains">!_</value>
					<value title="Not contains, case-insensitive">!_*</value>
					<value title="Starts with">^</value>
					<value title="Starts with, case-insensitive">^*</value>
					<value title="Not starts with">!^</value>
					<value title="Not starts with, case-insensitive">!^*</value>
					<value title="Ends with">$</value>
					<value title="Ends with, case-insensitive">$*</value>
					<value title="Not ends with">!$</value>
					<value title="Not ends with, case-insensitive">!$*</value>
					<value title="Matches regular expression">~</value>
					<value title="Matches regular expression, case-insensitive">~*</value>
					<value title="Not matches regular expression">!~</value>
					<value title="Not matches regular expression, case-insensitive">!~*</value>
					<value title="Is like">L</value>
					<value title="Is like, case-insensitive">L*</value>
					<value title="Is not like">!L</value>
					<value title="Is not like, case-insensitive">!L*</value>
				</attribute>
			</attributes>

			<attributes title="Field comparison">
				<attribute name="field1" type="string" title="Field name to compare from"/>
				<attribute name="field2" type="string" title="Field name to compare to"/>
			</attributes>

			<attributes title="Value comparison">
				<attribute name="field" type="string" title="Field name to compare from"/>
			</attributes>

			<content type="string" title="Value to compare to"/>
		</command>

		<command name="db:isnull" title="Is NULL condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:isnotnull" title="Is not NULL condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:exists" title="Exists condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:notexists" title="Not exists condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:in" title="In condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Variable name for static value list"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:notin" title="Not in condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Variable name for static value list"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:intags" title="In tags condition (ZeyOS)">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Variable name for static tag names list"/>
				<attribute name="entity" type="string" title="Entity name"/>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>

		<command name="db:any" title="Any condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>

				<attribute name="func" type="string" default="=" title="Comparison function">
					<value title="Equals">=</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
				</attribute>
			</attributes>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:all" title="All condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>

				<attribute name="func" type="string" default="=" title="Comparison function">
					<value title="Equals">=</value>
					<value title="Not equals">!=</value>
					<value title="Not equals">&lt;&gt;</value>
					<value title="Less than">&lt;</value>
					<value title="Less than or equal to">&lt;=</value>
					<value title="Greater than">&gt;</value>
					<value title="Greater than or equal to">&gt;=</value>
				</attribute>
			</attributes>

			<content type="string" title="SQL select statement"/>
		</command>

		<command name="db:search" title="Search condition">
			<parents>
				<parent>db:lookup</parent>
				<parent>db:select</parent>
				<parent>db:inner</parent>
				<parent>db:innerextdata</parent>
				<parent>db:innertags</parent>
				<parent>db:left</parent>
				<parent>db:leftextdata</parent>
				<parent>db:lefttags</parent>
				<parent>db:having</parent>
				<parent>db:update</parent>
				<parent>db:delete</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Variable name for field list"/>
				<attribute name="query" type="string" title="Query"/>
			</attributes>

			<content type="ixml"/>
		</command>

		<command name="db:searchfield" title="Search field">
			<parents>
				<parent>db:search</parent>
			</parents>

			<content type="string" title="Field name"/>
		</command>

		<command name="db:insert" title="Insert record">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name for insert ID"/>
				<attribute name="var_data" type="var" title="Variable name for associated field name and value pairs"/>
				<attribute name="table" type="string" title="Table name"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="int"/>

			<description>DB:INSERT executes a SQL/DML insert statement that inserts a new row into a table within the database.</description>
		</command>

		<command name="db:update" title="Update records">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="var_data" type="var" title="Variable name for associated field name and value pairs"/>
				<attribute name="table" type="string" title="Table name"/>
			</attributes>

			<content type="ixml"/>

			<description>DB:UPDATE executes a SQL/DML update statement that updates fields of existing rows in a table within the database.</description>
		</command>

		<command name="db:delete" title="Delete records">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<attributes>
				<attribute name="table" type="string" title="Table name"/>
			</attributes>

			<content type="ixml"/>

			<description>DB:DELETE executes a SQL/DML delete statement that deletes rows from a table within the database.</description>
		</command>

		<command name="db:transaction" title="Transaction">
			<parents>
				<parent>db:connection</parent>
			</parents>

			<content type="ixml"/>

			<description>DB:TRANSACTION specifies a transaction block for database and binary data store operations, ensuring that such processes leave the database and the binary data store in a consistent state even if an error occures within the transaction.</description>
			<description>Transactions provide an all-or-nothing proposition, stating that each work-unit performed within a transaction must either complete in its entirety or have no effect whatsoever.</description>

			<example title="Database">
				<!-- ignore -->
				<![CDATA[
					<db:set entity="contacts" id="123" var_data="obj"/>

					<try>
						<db:transaction>
							<db:set entity="contacts" id="123">
								<db:data field="lastname">New</db:data>
							</db:set>

							<error/>
						</db:transaction>

						<catch/>
					</try>

					<db:get var="obj" entity="contacts" id="123">
						<db:field>lastname</db:field>
					</db:get>

					<output>$obj.lastname</output>

					<!-- Old -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="extdata" title="Extensional data (ZeyOS)">
		<command name="extdata:get" title="Get extensional data">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_fields" type="var" title="Variable name for field list"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>EXTDATA:GET gets the extensional data of an object, specified by an entity and an ID.</description>

			<example title="Get data">
				<!-- ignore -->
				<![CDATA[
					<extdata:get var="obj" entity="contacts" id="123"/>
					<output>$obj.competitor</output>
					<!-- Steve Jobs -->
				]]>
			</example>

			<example title="Get and set data">
				<!-- ignore -->
				<![CDATA[
					<extdata:get var="obj" entity="contacts" id="123">
						<extdata:field>company</extdata:field>
					</extdata:get>

					<if value1="$obj.company" func="=" value2="Microsoft">
						<set var="obj.competitor">Apple</set>
					</if>

					<extdata:set entity="contacts" id="123" var_data="obj"/>
				]]>
			</example>
		</command>

		<command name="extdata:set" title="Set extensional data">
			<attributes>
				<attribute name="var_data" type="var" title="Variable name for associated field name and value pairs"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>

			<description>EXTDATA:SET sets the extensional data of an object, specified by an entity and an ID.</description>

			<example title="Set data">
				<!-- ignore -->
				<![CDATA[
					<extdata:set entity="contacts" id="123">
						<extdata:data field="company">Microsoft</extdata:data>
						<extdata:data field="competitor">Apple</extdata:data>
					</extdata:set>
				]]>
			</example>

			<example title="Get and set data">
				<!-- ignore -->
				<![CDATA[
					<extdata:get var="obj" entity="contacts" id="123">
						<extdata:field>company</extdata:field>
					</extdata:get>

					<if value1="$obj.company" func="=" value2="Microsoft">
						<set var="obj.competitor">Apple</set>
					</if>

					<extdata:set entity="contacts" id="123" var_data="obj"/>
				]]>
			</example>
		</command>

		<command name="extdata:unset" title="Unset extensional data">
			<attributes>
				<attribute name="var_fields" type="var" title="Variable name for field list"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>

			<description>EXTDATA:UNSET unsets the extensional data of an object, specified by an entity and an ID.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<extdata:unset entity="contacts" id="123">
						<extdata:field>company</extdata:field>
						<extdata:field>competitor</extdata:field>
					</extdata:unset>
				]]>
			</example>
		</command>

		<command name="extdata:field" title="Field">
			<parents>
				<parent>extdata:get</parent>
				<parent>extdata:unset</parent>
			</parents>

			<content type="string" title="Field name"/>
		</command>

		<command name="extdata:data" title="Data">
			<parents>
				<parent>extdata:set</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>

			<content type="string" title="Value"/>
		</command>

		<command name="extdata:null" title="NULL">
			<parents>
				<parent>extdata:set</parent>
			</parents>

			<attributes>
				<attribute name="field" type="string" title="Field name"/>
			</attributes>
		</command>
	</namespace>

	<namespace name="tags" title="Tags (ZeyOS)">
		<command name="tags:list" title="List all tags">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>TAGS:LIST lists all the tag names of an object, specified by an entity and an ID.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<tags:list var="tags" entity="contacts" id="123"/>
					<output>$tags[0]</output>
					<!-- Friends -->
				]]>
			</example>
		</command>

		<command name="tags:add" title="Add tags">
			<attributes>
				<attribute name="var_names" type="var" title="Variable name for tag names"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>

			<description>TAGS:ADD adds tags to an object, specified by an entity and an ID.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<tags:add entity="contacts" id="123">
						<tags:name>Friends</tags:name>
						<tags:name>A-Class</tags:name>
					</tags:add>
				]]>
			</example>
		</command>

		<command name="tags:remove" title="Remove tags">
			<attributes>
				<attribute name="var_names" type="var" title="Variable name for tag names"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>

			<description>TAGS:REMOVE removes tags from an object, specified by an entity and an ID.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<tags:remove entity="contacts" id="123">
						<tags:name>Friends</tags:name>
						<tags:name>A-Class</tags:name>
					</tags:remove>
				]]>
			</example>
		</command>

		<command name="tags:reset" title="Reset tags">
			<attributes>
				<attribute name="var_names" type="var" title="Variable name for tag names"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<content type="ixml"/>

			<description>TAGS:RESET removes all existing tags from and adds new tags to an object, specified by an entity and an ID.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<tags:reset entity="contacts" id="123">
						<tags:name>Friends</tags:name>
						<tags:name>A-Class</tags:name>
					</tags:reset>
				]]>
			</example>
		</command>

		<command name="tags:name" title="Name">
			<parents>
				<parent>tags:add</parent>
				<parent>tags:remove</parent>
			</parents>

			<content type="string" title="Tag name"/>
		</command>
	</namespace>

	<namespace name="bin" title="Binary data store (ZeyOS)">
		<command name="bin:read" title="Read binary data file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="id" type="int" title="ID"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>BIN:READ reads the entire content of a binary data file.</description>
			<description>BIN:READ is the complement of the BIN:WRITE operation.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<bin:write var="id">iXML</bin:write>

					<output>
						<bin:read id="$id"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="bin:write" title="Write binary data file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Content"/>
			<result binding="var" type="int"/>

			<description>BIN:WRITE writes content to a binary data file and returns its identifier.</description>
			<description>BIN:WRITE is the complement of the BIN:READ operation.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<bin:write var="id">iXML</bin:write>

					<output>
						<bin:read id="$id"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="temp" title="Temporary data store (ZeyOS)">
		<command name="temp:path" title="Path of temporary data file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="id" type="string" title="Identifier"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>TEMP:PATH returns the path of a temporary data file.</description>
		</command>

		<command name="temp:read" title="Read temporary data file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_struct" type="var" title="Result variable name for structural value"/>
				<attribute name="id" type="string" title="Identifier"/>
			</attributes>

			<result binding="var" type="string"/>
			<result binding="var_struct"/>

			<description>TEMP:READ reads the entire content of a temporary data file.</description>
			<description>TEMP:READ is the complement of the TEMP:WRITE operation.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<temp:write var="id">iXML</temp:write>

					<output>
						<temp:read id="$id"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="temp:write" title="Write temporary data file">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_struct" type="var" title="Variable name for structural value"/>
				<attribute name="id" type="string" default="(new)" title="Identifier"/>
			</attributes>

			<content type="string" title="Content"/>
			<result binding="var" type="string"/>

			<description>TEMP:WRITE writes content to a temporary data file and returns its identifier.</description>
			<description>If the identifier is omitted, it will implicitly be generated. If the temporary data file does not exist, it will implicitly be created. Otherwise, the existing temporary data file is overwritten.</description>
			<description>TEMP:WRITE is the complement of the TEMP:READ operation.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<temp:write var="id">iXML</temp:write>

					<output>
						<temp:read id="$id"/>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>

		<command name="temp:delete" title="Delete temporary data file">
			<attributes>
				<attribute name="id" type="string" title="Identifier"/>
			</attributes>

			<description>TEMP:DELETE deletes a temporary data file.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<temp:delete id="123"/>
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="mail" title="Mail (ZeyOS)">
		<command name="mail:parse" title="Parse message">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Raw message"/>
			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>MAIL:PARSE parses the raw format of an e-mail message according to RFC 2822.</description>
			<description>
				MAIL:PARSE returns an array comprised of the following items:

				Key               Description
				---------------------------------------------------
				date              date (Unix timestamp)
				subject           subject
				sender            sender
				sender_email      e-mail address of sender
				sender_name       name of sender
				to                recipients
				to_email          e-mail address of first recipient
				to_name           name of first recipient
				to_count          total number of recipients
				cc                recipients of carbon copy
				bcc               recipients of blind carbon copy
				messageid         message ID
				referenceid       in-reply-to message ID
				receipt           receipt flag
				autoreply         autoreply flag
				spam              spam flag
				contenttype       content type
				text              text part *
				html              html part *
				attachments       attachment parts *
				simpletext        simple text
				simpleattachments simple attachments

				* Each part is an array comprised of the following items:

				Key         Description
				-------------------------------------
				contenttype content type
				encoding    content transfer encoding
				charset     character set
				boundary    boundary delimiter
				disposition content disposition
				filename    filename
				contentid   content ID
				rawheader   raw header
				rawbody     raw body
			</description>
		</command>

		<command name="mail:queue" title="Queue message">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for message ID"/>
				<attribute name="mailserver" type="int" default="(default system SMTP server)" title="Mail server ID"/>
				<attribute name="senddate" type="int" default="(do not send)" title="Send date"/>
			</attributes>

			<children>
				<child name="mail:header" title="Mail header" occurrence="single">
					<content type="string" title="Raw message header"/>
				</child>

				<child name="mail:body" title="Mail body" occurrence="single">
					<content type="string" title="Raw message body"/>
				</child>
			</children>

			<result binding="var">
				<value type="int"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>MAIL:QUEUE consignes an e-mail message to the mail sending queue.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<mail:queue senddate="1262103817">
						<mail:header>
From: person@example.com
To: person@example.com
Date: Tue, 29 Dec 2009 17:23:37 +0100
Subject: This is the subject of the message
Content-Type: text/plain
						</mail:header>
						<mail:body>This is the body of the message.</mail:body>
					</mail:queue>
				]]>
			</example>
		</command>

		<command name="mail:send" title="Send message">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for message ID"/>
				<attribute name="mailserver" type="int" default="(default system SMTP server)" title="Mail server ID"/>
			</attributes>

			<children>
				<child name="mail:header" title="Mail header" occurrence="single">
					<content type="string" title="Raw message header"/>
				</child>

				<child name="mail:body" title="Mail body" occurrence="single">
					<content type="string" title="Raw message body"/>
				</child>
			</children>

			<result binding="var">
				<value type="int"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>MAIL:SEND consignes an e-mail message to the mail sending queue and sends it immediately.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<mail:send>
						<mail:header>
From: person@example.com
To: person@example.com
Date: Tue, 29 Dec 2009 17:23:37 +0100
Subject: This is the subject of the message
Content-Type: text/plain
						</mail:header>
						<mail:body>This is the body of the message.</mail:body>
					</mail:send>
				]]>
			</example>
		</command>

		<command name="mail:receive" title="Receive messages">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="server" type="string" title="Server"/>
				<attribute name="username" type="string" title="Username"/>
				<attribute name="password" type="string" title="Password"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>MAIL:RECEIVE fetches all e-mail messages from a POP3 server in raw format.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<mail:receive var="messages" server="localhost:110" username="username" password="password"/>
				]]>
			</example>
		</command>

		<command name="mail:multipart" title="Build multipart message">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="boundary" type="string" title="Boundary delimiter"/>
			</attributes>

			<content type="ixml"/>
			<result binding="var" type="string"/>

			<description>MAIL:MULTIPART builds a MIME multipart message body according to RFC 2046.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<mail:multipart var="rawbody" boundary="boundary">
						<mail:part>
							<mail:header>Content-Type: text/plain</mail:header>
							<mail:body>This is the body of the message.</mail:body>
						</mail:part>

						<mail:part>
							<mail:header>
Content-Type: text/html
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="message.html"
							</mail:header>
							<mail:body>PGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUgYm9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg==</mail:body>
						</mail:part>
					</mail:multipart>

					<output>$rawbody</output>
				]]>
			</example>
		</command>

		<command name="mail:part" title="Multipart message part">
			<parents>
				<parent>mail:multipart</parent>
			</parents>

			<children>
				<child name="mail:header" title="Mail header" occurrence="single">
					<content type="string" title="Raw message header"/>
				</child>

				<child name="mail:body" title="Mail body" occurrence="single">
					<content type="string" title="Raw message body"/>
				</child>
			</children>
		</command>

		<command name="mail:quote" title="Quote header value">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Header value"/>
			<result binding="var" type="string"/>

			<description>MAIL:QUOTE encodes a header value with MIME encoded-word syntax according to RFC 2047.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<output>
						<mail:quote>Header value with special characters such as Ã¤Ã¶Ã¼</mail:quote>
					</output>

					<!-- Header value with special characters such as =?UTF-8?Q?=C3=A4=C3=B6=C3=BC?= -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="excel" title="Excel">
		<command name="excel:workbook" title="Workbook">
			<attributes>
				<attribute name="filename" type="string" title="Filename"/>
				<attribute name="title" type="string" default="(initial title)" title="Title"/>
				<attribute name="subject" type="string" default="(initial subject)" title="Subject"/>
				<attribute name="keywords" type="string" default="(initial keywords)" title="Keywords"/>

				<attribute name="format" type="string" default="(filename extension)" title="File format">
					<value title="Microsoft Excel Binary File Format (BIFF)">Excel5</value>
					<value title="Microsoft Excel 2003 SpreadsheetML">Excel2003XML</value>
					<value title="Microsoft Office Open XML SpreadsheetML">Excel2007</value>
					<value title="Open Document Format for Office Applications (ODF)">OOCalc</value>
					<value title="Microsoft Multiplan Symbolic Link Interchange">SYLK</value>
					<value title="Gnome Gnumeric">Gnumeric</value>
					<value title="Comma-separated Values">CSV</value>
					<value title="HTML">HTML</value>
				</attribute>
			</attributes>

			<description>EXCEL:WORKBOOK creates or opens an existing Excel workbook.</description>
		</command>

		<command name="excel:length" title="Length">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="var_sheets" type="var" title="Result variable name for number of sheets"/>
				<attribute name="var_rows" type="var" title="Result variable name for number of rows"/>
				<attribute name="var_cols" type="var" title="Result variable name for number of columns"/>
			</attributes>

			<result binding="var_sheets" type="int" predicate="no-result-propagation"/>
			<result binding="var_rows" type="int" predicate="no-result-propagation"/>
			<result binding="var_cols" type="int" predicate="no-result-propagation"/>

			<description>EXCEL:LENGTH gets the number of sheets, rows and columns in context of the current position of the cell cursor.</description>
		</command>

		<command name="excel:next" title="Next cell">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="offset_sheet" type="int" title="Sheet offset"/>
				<attribute name="offset_row" type="int" title="Row offset"/>
				<attribute name="offset_col" type="int" default="1" title="Column offset"/>
			</attributes>

			<description>EXCEL:NEXT shifts the position of the cell cursor by a given offset.</description>
		</command>

		<command name="excel:getpos" title="Get position">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="var_coords" type="var" title="Result variable name for cell coordinates"/>
				<attribute name="var_sheet" type="var" title="Result variable name for sheet index"/>
				<attribute name="var_row" type="var" title="Result variable name for row index"/>
				<attribute name="var_col" type="var" title="Result variable name for column index"/>
			</attributes>

			<result binding="var_coords" type="string" predicate="no-result-propagation"/>
			<result binding="var_sheet" type="int" predicate="no-result-propagation"/>
			<result binding="var_row" type="int" predicate="no-result-propagation"/>
			<result binding="var_col" type="int" predicate="no-result-propagation"/>

			<description>EXCEL:GETPOS gets the current position of the cell cursor.</description>
		</command>

		<command name="excel:setpos" title="Set position">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes title="By index">
				<attribute name="sheet" type="int" default="(current sheet)" title="Sheet index"/>
				<attribute name="row" type="int" default="(current row)" title="Row index"/>
				<attribute name="col" type="int" default="(current column)" title="Column index"/>
			</attributes>

			<attributes title="By coordinates">
				<attribute name="coords" type="string" title="Cell coordinates"/>
			</attributes>

			<description>EXCEL:SETPOS sets the position of the cell cursor by given indices or by given coordinates.</description>
		</command>

		<command name="excel:get" title="Get cell value">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="coords" type="string" default="(current cell)" title="Cell coordinates"/>

				<attribute name="type" type="type" default="raw" title="Evaluation type">
					<value title="Raw">raw</value>
					<value title="Calculated">calculated</value>
					<value title="Formatted">formatted</value>
				</attribute>
			</attributes>

			<result binding="var" type="string"/>

			<description>EXCEL:GET gets the cell value at the current position of the cell cursor or at given coordinates.</description>
		</command>

		<command name="excel:set" title="Set cell value">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="coords" type="string" default="(current cell)"  title="Cell coordinates"/>
				<attribute name="format" type="string" default="(preserve existing format)" title="Format"/>

				<attribute name="type" type="type" default="auto" title="Data type">
					<value title="Automatic recognition">auto</value>
					<value title="Text">text</value>
					<value title="Numeric">numeric</value>
					<value title="Date">date</value>
					<value title="Boolean">bool</value>
					<value title="NULL">null</value>
				</attribute>
			</attributes>

			<content type="string" title="Value"/>

			<description>EXCEL:SET sets the cell value at the current position of the cell cursor or at given coordinates.</description>
		</command>

		<command name="excel:addsheet" title="Add sheet">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="index" type="int" default="(current sheet)" title="Sheet index"/>
			</attributes>

			<content type="string" title="Title"/>

			<description>EXCEL:ADDSHEET adds a new sheet.</description>
		</command>

		<command name="excel:removesheet" title="Remove sheet">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="index" type="int" default="(current sheet)" title="Sheet index"/>
			</attributes>

			<description>EXCEL:REMOVESHEET removes a sheet.</description>
		</command>

		<command name="excel:addrow" title="Add row">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="index" type="int" default="(current row)" title="Row index"/>
				<attribute name="height" type="float" default="(no specific height)" title="Height"/>
			</attributes>

			<description>EXCEL:ADDROW adds a new row.</description>
		</command>

		<command name="excel:removerow" title="Remove row">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="index" type="int" default="(current row)" title="Row index"/>
			</attributes>

			<description>EXCEL:REMOVEROW removes a row.</description>
		</command>

		<command name="excel:addcol" title="Add column">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="index" type="int" default="(current column)" title="Column index"/>
				<attribute name="width" type="float" default="(no specific width)" title="Width"/>
			</attributes>

			<content type="string" title="Title"/>

			<description>EXCEL:ADDCOL adds a new column.</description>
		</command>

		<command name="excel:removecol" title="Remove column">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="index" type="int" default="(current column)" title="Column index"/>
			</attributes>

			<description>EXCEL:REMOVECOL removes a column.</description>
		</command>

		<command name="excel:style" title="Style">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Variable name for associated style name and value pairs"/>
			</attributes>

			<content type="string" default="(current cell)" title="Cell range"/>

			<description>EXCEL:STYLE applies style to a range of cells.</description>
			<description>
				The given variable must be an array corresponding to the following structure (keys are case-insensitive):

				merge (range only)

				freeze (no range)

				heigth (no range)
				width (no range)

				collapseCol (no range)
				collapseRow (no range)

				outlineLevelCol (0-7) (no range)
				outlineLevelRow (0-7) (no range)

				font
					- name
					- bold
					- italic
					- superscript
					- subscript
					- underline: none, double, doubleAccounting, single, singleAccounting
					- strikethrough
					- color
						- rgb
						- argb
					- size

				alignment
					- horizontal: general, left, right, center, centerContinuous, justify, fill, distributed
					- verical: bottom, top, center, justify, distributed
					- textRotation
					- wrapText
					- shrinkToFit
					- indent
					- readOrder: 0 (context), 1 (ltr), 2 (rtl)

				borders
					- allBorders, left, right, top, bottom, diagonal, outline, inside, horizontal, vertical
						- borderStyle: none, dashDot, dashDotDot, dashed, dotted, double, hair, medium, mediumDashDot, mediumDashDotDot, mediumDashed, slantDashDot, thick, thin
						- color
							- rgb
							- argb
					- diagonalDirection: 0 (none), 1 (up), 2 (down), 3 (both)

				fill
					- fillType: none, solid, linear, path, darkDown, darkGray, darkGrid, darkHorizontal, darkTrellis, darkVertical, gray0625, gray125, lightDown, lightGray, lightGrid, lightHorizontal, lightTrellis, lightUp, lightVertical, mediumGray
					- rotation
					- startColor
						- rgb
						- argb
					- endColor
						- rgb
						- argb
					- color
						- rgb
						- argb

				numberFormat
					- formatCode

				protection
					- locked: inherit, protected, unprotected
					- hidden: inherit, protected, unprotected

				quotePrefix
			</description>
		</command>

		<command name="excel:autofilter" title="Auto filter">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<content type="string" default="(full sheet)" title="Cell range"/>

			<description>EXCEL:AUTOFILTER sets the auto filter for a range of cells.</description>
		</command>

		<command name="excel:array" title="To array">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>

				<attribute name="type" type="type" default="raw" title="Evaluation type">
					<value title="Raw">raw</value>
					<value title="Calculated">calculated</value>
					<value title="Formatted">formatted</value>
				</attribute>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>EXCEL:ARRAY extracts all cell values of a workbook into a multidimensional array.</description>
		</command>

		<command name="excel:create" title="Create">
			<parents>
				<parent>excel:workbook</parent>
			</parents>

			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>

				<attribute name="format" type="string" default="Excel2007" title="File format">
					<value title="Microsoft Excel Binary File Format (BIFF)">Excel5</value>
					<value title="Microsoft Office Open XML SpreadsheetML">Excel2007</value>
					<value title="Comma-separated Values">CSV</value>
					<value title="HTML">HTML</value>
					<value title="PDF">PDF</value>
				</attribute>
			</attributes>

			<description>EXCEL:CREATE generates an Excel workbook according to a given file format.</description>
		</command>
	</namespace>

	<namespace name="pdf" title="PDF">
		<command name="pdf:document" title="Document">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="author" type="string" title="Author"/>
				<attribute name="title" type="string" title="Title"/>
				<attribute name="subject" type="string" title="Subject"/>
				<attribute name="keywords" type="string" title="Keywords"/>
				<attribute name="subsetting" type="bool" title="Font subsetting"/>

				<attribute name="unit" type="string" default="mm" title="Unit">
					<value title="Millimeter">mm</value>
					<value title="Centimeter">cm</value>
					<value title="Inch">in</value>
					<value title="Point">pt</value>
				</attribute>

				<attribute name="zoom" type="string" default="default" title="Zoom">
					<value title="Full page on screen">fullpage</value>
					<value title="Maximum width of window">fullwidth</value>
					<value title="Real size">real</value>
					<value title="Viewer Default">default</value>
				</attribute>

				<attribute name="layout" type="string" default="SinglePage" title="Layout">
					<value title="One page at a time">SinglePage</value>
					<value title="Pages in one column">OneColumn</value>
					<value title="Pages in two columns, odd-numbered on the left">TwoColumnLeft</value>
					<value title="Pages in two columns, odd-numbered on the right">TwoColumnRight</value>
					<value title="Two pages at a time, odd-numbered on the left (PDF 1.5)">TwoPageLeft</value>
					<value title="Two pages at a time, odd-numbered on the right (PDF 1.5)">TwoPageRight</value>
				</attribute>

				<attribute name="mode" type="string" default="UseNone" title="Mode">
					<value title="None">UseNone</value>
					<value title="Document outline">UseOutlines</value>
					<value title="Thumbnail images">UseThumbs</value>
					<value title="Fullscreen">FullScreen</value>
					<value title="Content group panel (PDF 1.5)">UseOC</value>
					<value title="Attachments panel (PDF 1.6)">UseAttachments</value>
				</attribute>
			</attributes>

			<children>
				<child name="pdf:signature" title="Signature" occurrence="single">
					<attributes>
						<attribute name="signcert" type="string" title="Signing certificate (PEM notation)"/>
						<attribute name="privatekey" type="string" title="Private key (PEM notation)"/>
						<attribute name="password" type="string" title="Private key password"/>
						<attribute name="extracerts" type="string" title="Extra certificates (PEM notation)"/>
					</attributes>
				</child>
			</children>

			<content type="ixml"/>
			<result binding="var" type="string"/>

			<description>PDF:DOCUMENT generates a PDF document that is comprised of multiple sections.</description>
		</command>

		<command name="pdf:section" title="Section">
			<parents>
				<parent>pdf:document</parent>
			</parents>

			<attributes>
				<attribute name="orientation" type="string" default="P" title="Orientation">
					<value title="Portrait">P</value>
					<value title="Landscape">L</value>
				</attribute>

				<attribute name="format" type="string" default="A4" title="Format">
					<value title="A0">A0</value>
					<value title="A1">A1</value>
					<value title="A2">A2</value>
					<value title="A3">A3</value>
					<value title="A4">A4</value>
					<value title="A5">A5</value>
					<value title="A6">A6</value>
					<value title="A7">A7</value>
					<value title="A8">A8</value>
					<value title="A9">A9</value>
					<value title="A10">A10</value>
					<value title="A11">A11</value>
					<value title="A12">A12</value>
					<value title="B0">B0</value>
					<value title="B1">B1</value>
					<value title="B2">B2</value>
					<value title="B3">B3</value>
					<value title="B4">B4</value>
					<value title="B5">B5</value>
					<value title="B6">B6</value>
					<value title="B7">B7</value>
					<value title="B8">B8</value>
					<value title="B9">B9</value>
					<value title="B10">B10</value>
					<value title="B11">B11</value>
					<value title="B12">B12</value>
					<value title="C0">C0</value>
					<value title="C1">C1</value>
					<value title="C2">C2</value>
					<value title="C3">C3</value>
					<value title="C4">C4</value>
					<value title="C5">C5</value>
					<value title="C6">C6</value>
					<value title="C7">C7</value>
					<value title="C8">C8</value>
					<value title="C9">C9</value>
					<value title="C10">C10</value>
					<value title="C11">C11</value>
					<value title="C12">C12</value>
					<value title="C76">C76</value>
					<value title="DL">DL</value>
					<value title="E0">E0</value>
					<value title="E1">E1</value>
					<value title="E2">E2</value>
					<value title="E3">E3</value>
					<value title="E4">E4</value>
					<value title="E5">E5</value>
					<value title="E6">E6</value>
					<value title="E7">E7</value>
					<value title="E8">E8</value>
					<value title="E9">E9</value>
					<value title="E10">E10</value>
					<value title="E11">E11</value>
					<value title="E12">E12</value>
					<value title="G0">G0</value>
					<value title="G1">G1</value>
					<value title="G2">G2</value>
					<value title="G3">G3</value>
					<value title="G4">G4</value>
					<value title="G5">G5</value>
					<value title="G6">G6</value>
					<value title="G7">G7</value>
					<value title="G8">G8</value>
					<value title="G9">G9</value>
					<value title="G10">G10</value>
					<value title="G11">G11</value>
					<value title="G12">G12</value>
					<value title="RA0">RA0</value>
					<value title="RA1">RA1</value>
					<value title="RA2">RA2</value>
					<value title="RA3">RA3</value>
					<value title="RA4">RA4</value>
					<value title="SRA0">SRA0</value>
					<value title="SRA1">SRA1</value>
					<value title="SRA2">SRA2</value>
					<value title="SRA3">SRA3</value>
					<value title="SRA4">SRA4</value>
					<value title="4A0">4A0</value>
					<value title="2A0">2A0</value>
					<value title="A2_EXTRA">A2_EXTRA</value>
					<value title="A3+">A3+</value>
					<value title="A3_EXTRA">A3_EXTRA</value>
					<value title="A3_SUPER">A3_SUPER</value>
					<value title="SUPER_A3">SUPER_A3</value>
					<value title="A4_EXTRA">A4_EXTRA</value>
					<value title="A4_SUPER">A4_SUPER</value>
					<value title="SUPER_A4">SUPER_A4</value>
					<value title="A4_LONG">A4_LONG</value>
					<value title="F4">F4</value>
					<value title="SO_B5_EXTRA">SO_B5_EXTRA</value>
					<value title="A5_EXTRA">A5_EXTRA</value>
					<value title="ANSI_E">ANSI_E</value>
					<value title="ANSI_D">ANSI_D</value>
					<value title="ANSI_C">ANSI_C</value>
					<value title="ANSI_B">ANSI_B</value>
					<value title="ANSI_A">ANSI_A</value>
					<value title="USLEDGER">USLEDGER</value>
					<value title="LEDGER">LEDGER</value>
					<value title="ORGANIZERK">ORGANIZERK</value>
					<value title="BIBLE">BIBLE</value>
					<value title="USTABLOID">USTABLOID</value>
					<value title="TABLOID">TABLOID</value>
					<value title="ORGANIZERM">ORGANIZERM</value>
					<value title="USLETTER">USLETTER</value>
					<value title="LETTER">LETTER</value>
					<value title="USLEGAL">USLEGAL</value>
					<value title="LEGAL">LEGAL</value>
					<value title="GOVERNMENTLETTER">GOVERNMENTLETTER</value>
					<value title="GLETTER">GLETTER</value>
					<value title="JUNIORLEGAL">JUNIORLEGAL</value>
					<value title="JLEGAL">JLEGAL</value>
					<value title="QUADDEMY">QUADDEMY</value>
					<value title="SUPER_B">SUPER_B</value>
					<value title="QUARTO">QUARTO</value>
					<value title="GOVERNMENTLEGAL">GOVERNMENTLEGAL</value>
					<value title="FOLIO">FOLIO</value>
					<value title="MONARCH">MONARCH</value>
					<value title="EXECUTIVE">EXECUTIVE</value>
					<value title="ORGANIZERL">ORGANIZERL</value>
					<value title="STATEMENT">STATEMENT</value>
					<value title="MEMO">MEMO</value>
					<value title="FOOLSCAP">FOOLSCAP</value>
					<value title="COMPACT">COMPACT</value>
					<value title="ORGANIZERJ">ORGANIZERJ</value>
					<value title="P1">P1</value>
					<value title="P2">P2</value>
					<value title="P3">P3</value>
					<value title="P4">P4</value>
					<value title="P5">P5</value>
					<value title="P6">P6</value>
					<value title="ARCH_E">ARCH_E</value>
					<value title="ARCH_E1">ARCH_E1</value>
					<value title="ARCH_D">ARCH_D</value>
					<value title="BROADSHEET">BROADSHEET</value>
					<value title="ARCH_C">ARCH_C</value>
					<value title="ARCH_B">ARCH_B</value>
					<value title="ARCH_A">ARCH_A</value>
					<value title="ANNENV_A2">ANNENV_A2</value>
					<value title="ANNENV_A6">ANNENV_A6</value>
					<value title="ANNENV_A7">ANNENV_A7</value>
					<value title="ANNENV_A8">ANNENV_A8</value>
					<value title="ANNENV_A10">ANNENV_A10</value>
					<value title="ANNENV_SLIM">ANNENV_SLIM</value>
					<value title="COMMENV_N6_1/4">COMMENV_N6_1/4</value>
					<value title="COMMENV_N6_3/4">COMMENV_N6_3/4</value>
					<value title="COMMENV_N8">COMMENV_N8</value>
					<value title="COMMENV_N9">COMMENV_N9</value>
					<value title="COMMENV_N10">COMMENV_N10</value>
					<value title="COMMENV_N11">COMMENV_N11</value>
					<value title="COMMENV_N12">COMMENV_N12</value>
					<value title="COMMENV_N14">COMMENV_N14</value>
					<value title="CATENV_N1">CATENV_N1</value>
					<value title="CATENV_N1_3/4">CATENV_N1_3/4</value>
					<value title="CATENV_N2">CATENV_N2</value>
					<value title="CATENV_N3">CATENV_N3</value>
					<value title="CATENV_N6">CATENV_N6</value>
					<value title="CATENV_N7">CATENV_N7</value>
					<value title="CATENV_N8">CATENV_N8</value>
					<value title="CATENV_N9_1/2">CATENV_N9_1/2</value>
					<value title="CATENV_N9_3/4">CATENV_N9_3/4</value>
					<value title="CATENV_N10_1/2">CATENV_N10_1/2</value>
					<value title="CATENV_N12_1/2">CATENV_N12_1/2</value>
					<value title="CATENV_N13_1/2">CATENV_N13_1/2</value>
					<value title="CATENV_N14_1/4">CATENV_N14_1/4</value>
					<value title="CATENV_N14_1/2">CATENV_N14_1/2</value>
					<value title="JIS_B0">JIS_B0</value>
					<value title="JIS_B1">JIS_B1</value>
					<value title="JIS_B2">JIS_B2</value>
					<value title="JIS_B3">JIS_B3</value>
					<value title="JIS_B4">JIS_B4</value>
					<value title="JIS_B5">JIS_B5</value>
					<value title="JIS_B6">JIS_B6</value>
					<value title="JIS_B7">JIS_B7</value>
					<value title="JIS_B8">JIS_B8</value>
					<value title="JIS_B9">JIS_B9</value>
					<value title="JIS_B10">JIS_B10</value>
					<value title="JIS_B11">JIS_B11</value>
					<value title="JIS_B12">JIS_B12</value>
					<value title="PA0">PA0</value>
					<value title="PA1">PA1</value>
					<value title="PA2">PA2</value>
					<value title="PA3">PA3</value>
					<value title="PA4">PA4</value>
					<value title="PA5">PA5</value>
					<value title="PA6">PA6</value>
					<value title="PA7">PA7</value>
					<value title="PA8">PA8</value>
					<value title="PA9">PA9</value>
					<value title="PA10">PA10</value>
					<value title="PASSPORT_PHOTO">PASSPORT_PHOTO</value>
					<value title="E">E</value>
					<value title="L">L</value>
					<value title="3R">3R</value>
					<value title="KG">KG</value>
					<value title="4R">4R</value>
					<value title="4D">4D</value>
					<value title="2L">2L</value>
					<value title="5R">5R</value>
					<value title="8P">8P</value>
					<value title="6R">6R</value>
					<value title="6P">6P</value>
					<value title="8R">8R</value>
					<value title="6PW">6PW</value>
					<value title="S8R">S8R</value>
					<value title="4P">4P</value>
					<value title="10R">10R</value>
					<value title="4PW">4PW</value>
					<value title="S10R">S10R</value>
					<value title="11R">11R</value>
					<value title="S11R">S11R</value>
					<value title="12R">12R</value>
					<value title="S12R">S12R</value>
					<value title="NEWSPAPER_BROADSHEET">NEWSPAPER_BROADSHEET</value>
					<value title="NEWSPAPER_BERLINER">NEWSPAPER_BERLINER</value>
					<value title="NEWSPAPER_TABLOID">NEWSPAPER_TABLOID</value>
					<value title="NEWSPAPER_COMPACT">NEWSPAPER_COMPACT</value>
					<value title="CREDIT_CARD">CREDIT_CARD</value>
					<value title="BUSINESS_CARD">BUSINESS_CARD</value>
					<value title="BUSINESS_CARD_ISO7810">BUSINESS_CARD_ISO7810</value>
					<value title="BUSINESS_CARD_ISO216">BUSINESS_CARD_ISO216</value>
					<value title="BUSINESS_CARD_IT">BUSINESS_CARD_IT</value>
					<value title="BUSINESS_CARD_UK">BUSINESS_CARD_UK</value>
					<value title="BUSINESS_CARD_FR">BUSINESS_CARD_FR</value>
					<value title="BUSINESS_CARD_DE">BUSINESS_CARD_DE</value>
					<value title="BUSINESS_CARD_ES">BUSINESS_CARD_ES</value>
					<value title="BUSINESS_CARD_CA">BUSINESS_CARD_CA</value>
					<value title="BUSINESS_CARD_US">BUSINESS_CARD_US</value>
					<value title="BUSINESS_CARD_JP">BUSINESS_CARD_JP</value>
					<value title="BUSINESS_CARD_HK">BUSINESS_CARD_HK</value>
					<value title="BUSINESS_CARD_AU">BUSINESS_CARD_AU</value>
					<value title="BUSINESS_CARD_DK">BUSINESS_CARD_DK</value>
					<value title="BUSINESS_CARD_SE">BUSINESS_CARD_SE</value>
					<value title="BUSINESS_CARD_RU">BUSINESS_CARD_RU</value>
					<value title="BUSINESS_CARD_CZ">BUSINESS_CARD_CZ</value>
					<value title="BUSINESS_CARD_FI">BUSINESS_CARD_FI</value>
					<value title="BUSINESS_CARD_HU">BUSINESS_CARD_HU</value>
					<value title="BUSINESS_CARD_IL">BUSINESS_CARD_IL</value>
					<value title="4SHEET">4SHEET</value>
					<value title="6SHEET">6SHEET</value>
					<value title="12SHEET">12SHEET</value>
					<value title="16SHEET">16SHEET</value>
					<value title="32SHEET">32SHEET</value>
					<value title="48SHEET">48SHEET</value>
					<value title="64SHEET">64SHEET</value>
					<value title="96SHEET">96SHEET</value>
					<value title="EN_EMPEROR">EN_EMPEROR</value>
					<value title="EN_ANTIQUARIAN">EN_ANTIQUARIAN</value>
					<value title="EN_GRAND_EAGLE">EN_GRAND_EAGLE</value>
					<value title="EN_DOUBLE_ELEPHANT">EN_DOUBLE_ELEPHANT</value>
					<value title="EN_ATLAS">EN_ATLAS</value>
					<value title="EN_COLOMBIER">EN_COLOMBIER</value>
					<value title="EN_ELEPHANT">EN_ELEPHANT</value>
					<value title="EN_DOUBLE_DEMY">EN_DOUBLE_DEMY</value>
					<value title="EN_IMPERIAL">EN_IMPERIAL</value>
					<value title="EN_PRINCESS">EN_PRINCESS</value>
					<value title="EN_CARTRIDGE">EN_CARTRIDGE</value>
					<value title="EN_DOUBLE_LARGE_POST">EN_DOUBLE_LARGE_POST</value>
					<value title="EN_ROYAL">EN_ROYAL</value>
					<value title="EN_SHEET">EN_SHEET</value>
					<value title="EN_HALF_POST">EN_HALF_POST</value>
					<value title="EN_SUPER_ROYAL">EN_SUPER_ROYAL</value>
					<value title="EN_DOUBLE_POST">EN_DOUBLE_POST</value>
					<value title="EN_MEDIUM">EN_MEDIUM</value>
					<value title="EN_DEMY">EN_DEMY</value>
					<value title="EN_LARGE_POST">EN_LARGE_POST</value>
					<value title="EN_COPY_DRAUGHT">EN_COPY_DRAUGHT</value>
					<value title="EN_POST">EN_POST</value>
					<value title="EN_CROWN">EN_CROWN</value>
					<value title="EN_PINCHED_POST">EN_PINCHED_POST</value>
					<value title="EN_BRIEF">EN_BRIEF</value>
					<value title="EN_FOOLSCAP">EN_FOOLSCAP</value>
					<value title="EN_SMALL_FOOLSCAP">EN_SMALL_FOOLSCAP</value>
					<value title="EN_POTT">EN_POTT</value>
					<value title="BE_GRAND_AIGLE">BE_GRAND_AIGLE</value>
					<value title="BE_COLOMBIER">BE_COLOMBIER</value>
					<value title="BE_DOUBLE_CARRE">BE_DOUBLE_CARRE</value>
					<value title="BE_ELEPHANT">BE_ELEPHANT</value>
					<value title="BE_PETIT_AIGLE">BE_PETIT_AIGLE</value>
					<value title="BE_GRAND_JESUS">BE_GRAND_JESUS</value>
					<value title="BE_JESUS">BE_JESUS</value>
					<value title="BE_RAISIN">BE_RAISIN</value>
					<value title="BE_GRAND_MEDIAN">BE_GRAND_MEDIAN</value>
					<value title="BE_DOUBLE_POSTE">BE_DOUBLE_POSTE</value>
					<value title="BE_COQUILLE">BE_COQUILLE</value>
					<value title="BE_PETIT_MEDIAN">BE_PETIT_MEDIAN</value>
					<value title="BE_RUCHE">BE_RUCHE</value>
					<value title="BE_PROPATRIA">BE_PROPATRIA</value>
					<value title="BE_LYS">BE_LYS</value>
					<value title="BE_POT">BE_POT</value>
					<value title="BE_ROSETTE">BE_ROSETTE</value>
					<value title="FR_UNIVERS">FR_UNIVERS</value>
					<value title="FR_DOUBLE_COLOMBIER">FR_DOUBLE_COLOMBIER</value>
					<value title="FR_GRANDE_MONDE">FR_GRANDE_MONDE</value>
					<value title="FR_DOUBLE_SOLEIL">FR_DOUBLE_SOLEIL</value>
					<value title="FR_DOUBLE_JESUS">FR_DOUBLE_JESUS</value>
					<value title="FR_GRAND_AIGLE">FR_GRAND_AIGLE</value>
					<value title="FR_PETIT_AIGLE">FR_PETIT_AIGLE</value>
					<value title="FR_DOUBLE_RAISIN">FR_DOUBLE_RAISIN</value>
					<value title="FR_JOURNAL">FR_JOURNAL</value>
					<value title="FR_COLOMBIER_AFFICHE">FR_COLOMBIER_AFFICHE</value>
					<value title="FR_DOUBLE_CAVALIER">FR_DOUBLE_CAVALIER</value>
					<value title="FR_CLOCHE">FR_CLOCHE</value>
					<value title="FR_SOLEIL">FR_SOLEIL</value>
					<value title="FR_DOUBLE_CARRE">FR_DOUBLE_CARRE</value>
					<value title="FR_DOUBLE_COQUILLE">FR_DOUBLE_COQUILLE</value>
					<value title="FR_JESUS">FR_JESUS</value>
					<value title="FR_RAISIN">FR_RAISIN</value>
					<value title="FR_CAVALIER">FR_CAVALIER</value>
					<value title="FR_DOUBLE_COURONNE">FR_DOUBLE_COURONNE</value>
					<value title="FR_CARRE">FR_CARRE</value>
					<value title="FR_COQUILLE">FR_COQUILLE</value>
					<value title="FR_DOUBLE_TELLIERE">FR_DOUBLE_TELLIERE</value>
					<value title="FR_DOUBLE_CLOCHE">FR_DOUBLE_CLOCHE</value>
					<value title="FR_DOUBLE_POT">FR_DOUBLE_POT</value>
					<value title="FR_ECU">FR_ECU</value>
					<value title="FR_COURONNE">FR_COURONNE</value>
					<value title="FR_TELLIERE">FR_TELLIERE</value>
					<value title="FR_POT">FR_POT</value>
				</attribute>

				<attribute name="height" type="float" title="Page height"/>
				<attribute name="width" type="float" title="Page width"/>

				<attribute name="leftmargin" type="float" title="Left margin"/>
				<attribute name="rightmargin" type="float" title="Right margin"/>
				<attribute name="topmargin" type="float" title="Top margin"/>
				<attribute name="bottommargin" type="float" title="Bottom margin"/>
			</attributes>

			<children>
				<child name="pdf:templates" title="Templates" occurrence="single">
					<attributes>
						<attribute name="filename" type="string" title="Filename/URL (local only)"/>
					</attributes>

					<content type="ixml"/>
				</child>

				<child name="pdf:header" title="Header" occurrence="single">
					<content type="ixml"/>
				</child>

				<child name="pdf:footer" title="Footer" occurrence="single">
					<content type="ixml"/>
				</child>

				<child name="pdf:body" title="Body" occurrence="single">
					<content type="ixml"/>
				</child>
			</children>

			<description>PDF:SECTION represents a thematic grouping of content, with a header, a footer and a body.</description>
		</command>

		<command name="pdf:template" title="Template">
			<parents>
				<parent>pdf:templates</parent>
			</parents>

			<attributes>
				<attribute name="source" type="int" default="1" title="Source page number"/>
				<attribute name="target" type="int" default="(all pages)" title="Target page number"/>
			</attributes>

			<description>PDF:TEMPLATE imports a page as a template.</description>
		</command>

		<command name="pdf:style" title="Style">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="align" type="string" default="(parent style, initially L)" title="Horizontal alignment">
					<value title="Left">L</value>
					<value title="Center">C</value>
					<value title="Right">R</value>
					<value title="Justify">J</value>
				</attribute>

				<attribute name="valign" type="string" default="(parent style)" title="Vertical alignment">
					<value title="Top">T</value>
					<value title="Middle">M</value>
					<value title="Bottom">B</value>
				</attribute>

				<attribute name="dir" type="string" default="(parent style, initially LTR)" title="Text direction">
					<value title="Left-to-right">LTR</value>
					<value title="Right-to-left">RTL</value>
				</attribute>

				<attribute name="font" type="string" default="(parent style, initially arial)" title="Font family">
					<value title="Arial">arial</value>
					<value title="Serif">serif</value>
					<value title="Sans-serif">sans</value>
					<value title="Monospace">mono</value>
				</attribute>

				<attribute name="fontstyle" type="string" default="(parent style)" title="Font style">
					<value title="Bold">B</value>
					<value title="Italic">I</value>
					<value title="Underline">U</value>
					<value title="Overline">O</value>
					<value title="Line-through">D</value>
				</attribute>

				<attribute name="fontsize" type="float" default="(parent style, initially 12)" title="Font size (pt)"/>
				<attribute name="fontspace" type="float" default="(parent style)" title="Font spacing"/>
				<attribute name="fontstretch" type="int" default="(parent style, initially 100)" title="Font stretching (%)"/>

				<attribute name="bgcolor" type="string" default="(parent style)" title="Background color"/>
				<attribute name="textcolor" type="string" default="(parent style, initially #000)" title="Text color"/>

				<attribute name="border" type="string" default="(parent style)" title="Border">
					<value title="Left">L</value>
					<value title="Right">R</value>
					<value title="Top">T</value>
					<value title="Bottom">B</value>
				</attribute>

				<attribute name="borderwidth" type="float" default="(parent style)" title="Border width"/>
				<attribute name="bordercolor" type="string" default="(parent style, initially #000)" title="Border color"/>

				<attribute name="lineheight" type="float" default="(parent style)" title="Line height"/>
				<attribute name="padding" type="float" default="(parent style)" title="Padding"/>

				<attribute name="rotate" type="int" default="(parent style)" title="Rotate (degrees)"/>
			</attributes>

			<content type="ixml"/>

			<description>PDF:STYLE defines the style for its content.</description>
		</command>

		<command name="pdf:linebreak" title="Line break">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="offset" type="float" title="Offset"/>
			</attributes>

			<description>PDF:LINEBREAK adds a new line and shifts the ordinate by a given offset.</description>
		</command>

		<command name="pdf:pagebreak" title="Page break">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="offset" type="float" title="Offset"/>
			</attributes>

			<description>PDF:PAGEBREAK adds a new page and shifts the ordinate to a given offset.</description>
		</command>

		<command name="pdf:inline" title="Inline text">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="html" type="bool" title="HTML content"/>
				<attribute name="leftmargin" type="float" title="Left margin"/>
				<attribute name="rightmargin" type="float" title="Right margin"/>
				<attribute name="x" type="float" default="(current abscissa)" title="Abscissa"/>
				<attribute name="y" type="float" default="(current ordinate)" title="Ordinate"/>
			</attributes>

			<content type="string" title="Text"/>

			<description>PDF:INLINE prints text as flow content.</description>
		</command>

		<command name="pdf:block" title="Block text">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="html" type="bool" title="HTML content"/>
				<attribute name="nowrap" type="bool" title="No text wrapping"/>
				<attribute name="height" type="float" title="Minimum Height"/>
				<attribute name="width" type="float" default="(expands to right margin)" title="Width"/>
				<attribute name="leftmargin" type="float" title="Left margin"/>
				<attribute name="rightmargin" type="float" title="Right margin"/>
				<attribute name="x" type="float" default="(current abscissa)" title="Abscissa"/>
				<attribute name="y" type="float" default="(current ordinate)" title="Ordinate"/>
			</attributes>

			<content type="string" title="Text"/>

			<description>PDF:BLOCK prints a block of text as sectioning content.</description>
		</command>

		<command name="pdf:row" title="Row">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="leftmargin" type="float" title="Left margin"/>
				<attribute name="rightmargin" type="float" title="Right margin"/>
				<attribute name="x" type="float" default="(current abscissa)" title="Abscissa"/>
				<attribute name="y" type="float" default="(current ordinate)" title="Ordinate"/>
			</attributes>

			<content type="ixml"/>

			<description>PDF:ROW prints a row of text columns as tabular content.</description>
		</command>

		<command name="pdf:col" title="Column">
			<parents>
				<parent>pdf:row</parent>
			</parents>

			<attributes>
				<attribute name="html" type="bool" title="HTML content"/>
				<attribute name="nowrap" type="bool" title="No text wrapping"/>
				<attribute name="height" type="float" title="Minimum Height"/>
				<attribute name="width" type="float" default="(expands to right margin)" title="Width"/>
			</attributes>

			<content type="string" title="Text"/>
		</command>

		<command name="pdf:image" title="Image">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="filename" type="string" title="Filename/URL"/>
				<attribute name="type" type="string" default="(filename extension)" title="Image type"/>
				<attribute name="dpi" type="int" default="300" title="Dots per inch"/>
				<attribute name="height" type="float" default="(image height)" title="Height"/>
				<attribute name="width" type="float" default="(image width)" title="Width"/>
				<attribute name="x" type="float" default="(current abscissa)" title="Abscissa"/>
				<attribute name="y" type="float" default="(current ordinate)" title="Ordinate"/>
			</attributes>

			<description>PDF:IMAGE prints an image, specified by a filename/URL.</description>
			<description>If the type is omitted, it will implicitly be inferred from the filename extension component of the given filename.</description>
		</command>

		<command name="pdf:barcode" title="Barcode">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="type" type="string" default="C128" title="Barcode type">
					<value title="CODE 39 - ANSI MH10.8M-1983 - USD-3 - 3 of 9">C39</value>
					<value title="CODE 39 + CHECKSUM">C39+</value>
					<value title="CODE 39 EXTENDED">C39E</value>
					<value title="CODE 39 EXTENDED + CHECKSUM">C39E+</value>
					<value title="CODE 93 - USS-93">C93</value>
					<value title="Standard 2 of 5">S25</value>
					<value title="Standard 2 of 5 + CHECKSUM">S25+</value>
					<value title="Interleaved 2 of 5">I25</value>
					<value title="Interleaved 2 of 5 + CHECKSUM">I25+</value>
					<value title="CODE 128">C128</value>
					<value title="CODE 128 A">C128A</value>
					<value title="CODE 128 B">C128B</value>
					<value title="CODE 128 C">C128C</value>
					<value title="2-Digits UPC-Based Extention">EAN2</value>
					<value title="5-Digits UPC-Based Extention">EAN5</value>
					<value title="EAN 8">EAN8</value>
					<value title="EAN 13">EAN13</value>
					<value title="UPC-A">UPCA</value>
					<value title="UPC-E">UPCE</value>
					<value title="MSI (Variation of Plessey code)">MSI</value>
					<value title="MSI + CHECKSUM">MSI+</value>
					<value title="POSTNET">POSTNET</value>
					<value title="PLANET">PLANET</value>
					<value title="RMS4CC (Royal Mail 4-state Customer Code) - CBC (Customer Bar Code)">RMS4CC</value>
					<value title="KIX (Klant index - Customer index)">KIX</value>
					<value title="Intelligent Mail Barcode - Onecode - USPS-B-3200">IMB</value>
					<value title="CODABAR">CODABAR</value>
					<value title="CODE 11">CODE11</value>
					<value title="PHARMACODE">PHARMA</value>
					<value title="PHARMACODE TWO-TRACKS">PHARMA2T</value>
					<value title="DATAMATRIX">DATAMATRIX</value>
					<value title="QR-CODE">QRCODE</value>
					<value title="QR-CODE Low error correction">QRCODE,L</value>
					<value title="QR-CODE Medium error correction">QRCODE,M</value>
					<value title="QR-CODE Better error correction">QRCODE,Q</value>
					<value title="QR-CODE Best error correction">QRCODE,H</value>
					<value title="PDF417">PDF417</value>
				</attribute>

				<attribute name="height" type="float" title="Height"/>
				<attribute name="width" type="float" default="(expands to right margin)" title="Width"/>
				<attribute name="x" type="float" default="(current abscissa)" title="Abscissa"/>
				<attribute name="y" type="float" default="(current ordinate)" title="Ordinate"/>
				<attribute name="resolution" type="float" default="(default resolution)" title="Resolution"/>
			</attributes>

			<content type="string" title="Code"/>

			<description>PDF:BARCODE prints a linear or matrix bar code, specified by a given type.</description>
		</command>

		<command name="pdf:getpos" title="Get position">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="var_page" type="var" title="Result variable name for page number"/>
				<attribute name="var_subpage" type="var" title="Result variable name for section page number"/>
				<attribute name="var_x" type="var" title="Result variable name for abscissa"/>
				<attribute name="var_y" type="var" title="Result variable name for ordinate"/>
			</attributes>

			<result binding="var_page" type="int" predicate="no-result-propagation"/>
			<result binding="var_subpage" type="int" predicate="no-result-propagation"/>
			<result binding="var_x" type="float" predicate="no-result-propagation"/>
			<result binding="var_y" type="float" predicate="no-result-propagation"/>

			<description>PDF:GETPOS gets the current position.</description>
		</command>

		<command name="pdf:setpos" title="Set position">
			<parents>
				<parent>pdf:header</parent>
				<parent>pdf:footer</parent>
				<parent>pdf:body</parent>
			</parents>

			<attributes>
				<attribute name="page" type="int" default="(current page)" title="Page number"/>
				<attribute name="x" type="float" default="(current abscissa)" title="Abscissa"/>
				<attribute name="y" type="float" default="(current ordinate)" title="Ordinate"/>
			</attributes>

			<description>PDF:SETPOS sets the position.</description>
		</command>
	</namespace>

	<namespace name="numformat" title="Number format (ZeyOS)">
		<command name="numformat:get" title="Get next number">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for formatted number"/>
				<attribute name="name" type="string" title="Name"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>NUMFORMAT:GET returns the next formatted number, specified by name.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<numformat:get var="number" name="billing_invoicenum"/>
				]]>
			</example>
		</command>

		<command name="numformat:inc" title="Increment counter">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for new counter"/>
				<attribute name="name" type="string" title="Name"/>
			</attributes>

			<content type="int" default="1"/>

			<result binding="var" type="int"/>

			<description>NUMFORMAT:INC increments and returns the counter of a formatted number, specified by name.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<numformat:inc name="billing_invoicenum"/>
				]]>
			</example>
		</command>

		<command name="numformat:next" title="Get next number and increment counter">
			<attributes>
				<attribute name="var" type="var" title="Result variable name for formatted number"/>
				<attribute name="name" type="string" title="Name"/>
			</attributes>

			<result binding="var" type="string"/>

			<description>NUMFORMAT:NEXT returns the next formatted number and icnrements the counter, specified by name.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<numformat:next var="number" name="billing_invoicenum"/>
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="auth" title="Authentication (ZeyOS)">
		<command name="auth:simple" title="Simple authentication">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="username" type="string" title="Username"/>
				<attribute name="password" type="string" title="Password"/>
				<attribute name="otp" type="string" title="OTP validation code"/>
			</attributes>

			<result binding="var" predicate="no-result-propagation">
				<value type="array"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>AUTH:SIMPLE authenticates a user by username and password.</description>
		</command>

		<command name="auth:login" title="Token login">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="username" type="string" title="Username"/>
				<attribute name="password" type="string" title="Password"/>
				<attribute name="identifier" type="string" title="Identifier"/>
				<attribute name="appsecret" type="string" title="Application secret key"/>
				<attribute name="otp" type="string" title="OTP validation code"/>
				<attribute name="expdate" type="int" default="(no expiration)" title="Expiry date"/>
			</attributes>

			<result binding="var" predicate="no-result-propagation">
				<value type="array"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>AUTH:LOGIN authenticates a user by username and password and generates a session token.</description>
		</command>

		<command name="auth:logout" title="Token logout">
			<content type="string" title="Token"/>

			<description>AUTH:LOGOUT invalidates a session token.</description>
		</command>

		<command name="auth:validate" title="Token validation">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<content type="string" title="Token"/>

			<result binding="var" predicate="no-result-propagation">
				<value type="array"/>
				<value type="null" title="Invalid">NULL</value>
			</result>

			<description>AUTH:VALIDATE validates a session token.</description>
		</command>
	</namespace>

	<namespace name="misc" title="Miscellaneous (ZeyOS)">
		<command name="session" title="Session information">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" predicate="no-result-propagation">
				<value type="array"/>
				<value type="null" title="No session">NULL</value>
			</result>

			<description>SESSION returns information about the current browser session.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<session var="session"/>
				]]>
			</example>
		</command>

		<command name="config" title="Configuration information">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<description>CONFIG returns information about the system configuration.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<config var="config"/>
				]]>
			</example>
		</command>

		<command name="resetcron" title="Reset cron scheduler">
			<content type="string" title="Cron name"/>

			<description>RESETCRON resets a cron scheduler.</description>
		</command>

		<command name="transitems" title="Initialize transaction items">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<result binding="var" type="array" predicate="no-result-propagation"/>

			<attention>TRANSITEMS is destructive, in the sense that it modifies the array in-place. It will re-index all keys in the array numerically.</attention>
		</command>

		<command name="zymba:run" title="Run embedded Zymba">
			<attributes>
				<attribute name="var" type="var" title="Result variable name"/>
				<attribute name="var_params" type="var" title="Variable name for associated parameter name and value pairs"/>
			</attributes>

			<children>
				<child name="zymba:code" title="Code" occurrence="single">
					<content type="string" title="Zymba source code"/>
				</child>
			</children>

			<content type="ixml"/>
			<result binding="var"/>

			<description>ZYMBA parses and executes Zymba code. Arguments may be passed to global Zymba variables as parameters.</description>

			<example>
				<!-- ignore -->
				<![CDATA[
					<set var="name">iXML</set>

					<output>
						<zymba:run>
							<param var="name"/>

							<zymba:code>return @name;</zymba:code>
						</zymba:run>
					</output>

					<!-- iXML -->
				]]>
			</example>
		</command>
	</namespace>

	<namespace name="form" title="Form (ZeyOS)">
		<command name="hbox" title="Horizontal box">
			<attributes>
				<attribute name="align" type="string" title="Content alignment (CSS)"/>
				<attribute name="height" type="string" title="Height (CSS)"/>
				<attribute name="width" type="string" title="Width (CSS)"/>
				<attribute name="padding" type="string" title="Padding (CSS)"/>
			</attributes>

			<content type="ixml"/>

			<description>HBOX represents a set of form controls horizontally aligned like tabular columns.</description>
		</command>

		<command name="vbox" title="Vertical box">
			<attributes>
				<attribute name="align" type="string" title="Content alignment (CSS)"/>
				<attribute name="height" type="string" title="Height (CSS)"/>
				<attribute name="width" type="string" title="Width (CSS)"/>
				<attribute name="padding" type="string" title="Padding (CSS)"/>
			</attributes>

			<content type="ixml"/>

			<description>VBOX represents a set of form controls vertically aligned like tabular rows.</description>
		</command>

		<command name="placeholder" title="Placeholder">
			<attributes>
				<attribute name="height" type="string" title="Height (CSS)"/>
				<attribute name="width" type="string" title="Width (CSS)"/>
			</attributes>

			<description>PALCEHOLDER represents an empty placeholder.</description>
		</command>

		<command name="title" title="Section title">
			<content type="string" title="Text"/>

			<description>TITLE represents a section title with a text that is displayed with an emphasized style.</description>
		</command>

		<command name="description" title="Description">
			<attributes>
				<attribute name="label" type="string" title="Label"/>
			</attributes>

			<content type="string" title="Text"/>

			<description>DESCRIPTION represents a description with a text that is displayed with a normal style and is attached to a label.</description>
		</command>

		<command name="link" title="Hyperlink">
			<attributes>
				<attribute name="label" type="string" title="Label"/>
				<attribute name="url" type="string" title="URL"/>
			</attributes>

			<content type="string" title="Text"/>

			<description>LINK represents a hyperlink with a text that links to an URL and is displayed with a normal style and is attached to a label.</description>
		</command>

		<command name="image" title="Image">
			<attributes>
				<attribute name="label" type="string" title="Label"/>
				<attribute name="caption" type="string" title="Caption"/>
				<attribute name="url" type="string" title="URL"/>
			</attributes>

			<content type="string" title="Source"/>

			<description>IMAGE represents an image that optionally links to an URL and is attached to a label.</description>
		</command>

		<command name="rule" title="Horizontal rule">
			<attributes>
				<attribute name="width" type="string" title="Width (CSS)"/>
			</attributes>

			<description>RULE represents a horizontal rule to be used as a thematic break.</description>
		</command>

		<command name="checkbox" title="Check box">
			<attributes>
				<attribute name="id" type="var" title="Identifier"/>
				<attribute name="label" type="string" title="Label"/>
				<attribute name="caption" type="string" title="Caption"/>
				<attribute name="selected" type="bool" title="Initially selected"/>
				<attribute name="disabled" type="bool" title="Disabled"/>
			</attributes>

			<content type="string" default="1" title="Value"/>

			<description>CHECKBOX represents a two-state form control that displays the checkedness of a data element and is attached to a label.</description>
		</command>

		<command name="listbox" title="List box">
			<attributes>
				<attribute name="id" type="var" title="Identifier"/>
				<attribute name="label" type="string" title="Label"/>
				<attribute name="disabled" type="bool" title="Disabled"/>
				<attribute name="required" type="bool" title="Required"/>
				<attribute name="width" type="string" title="Width (CSS)"/>

				<attribute name="type" type="type" default="single" title="Input type">
					<value title="Single select">single</value>
					<value title="Multiple check">multi</value>
				</attribute>
			</attributes>

			<attributes title="Single select">
				<attribute name="caption" type="string" title="Caption"/>
			</attributes>

			<attributes title="Multiple check">
				<attribute name="height" type="string" title="Height (CSS)"/>
			</attributes>

			<content type="ixml"/>

			<description>LISTBOX represents a form control for selecting one or multiple data element among a set of unique options that are displayed as a list of items and are attached to a label.</description>
		</command>

		<command name="listitem" title="List item">
			<parents>
				<parent>listbox</parent>
			</parents>

			<attributes>
				<attribute name="caption" type="string" default="(same as value)" title="Caption"/>
				<attribute name="selected" type="bool" title="Initially selected"/>
			</attributes>

			<content type="string" default="(consecutive number, starting with zero)" title="Value"/>
		</command>

		<command name="entitybox" title="Entity box">
			<attributes>
				<attribute name="id" type="var" title="Identifier"/>
				<attribute name="entity" type="string" title="Entity"/>
				<attribute name="tag" type="string" title="Tag filter"/>
				<attribute name="label" type="string" title="Label"/>
				<attribute name="caption" type="string" title="Caption"/>
				<attribute name="disabled" type="bool" title="Disabled"/>
				<attribute name="required" type="bool" title="Required"/>
				<attribute name="placeholder" type="string" title="Placeholder"/>
				<attribute name="width" type="string" title="Width (CSS)"/>
			</attributes>

			<description>ENTITYBOX represents a form control for selecting an object ID among a set of entity related objects that are displayed as a list of items and are attached to a label.</description>
		</command>

		<command name="textbox" title="Text box">
			<attributes>
				<attribute name="id" type="var" title="Identifier"/>
				<attribute name="label" type="string" title="Label"/>
				<attribute name="disabled" type="bool" title="Disabled"/>
				<attribute name="required" type="bool" title="Required"/>
				<attribute name="readonly" type="bool" title="Read-only"/>
				<attribute name="placeholder" type="string" title="Placeholder"/>
				<attribute name="width" type="string" title="Width (CSS)"/>

				<attribute name="type" type="type" default="single" title="Input type">
					<value title="Single line">single</value>
					<value title="Multiple lines">multi</value>
					<value title="HTML">html</value>
					<value title="E-Mail">email</value>
					<value title="URL">url</value>
					<value title="Telephone">tel</value>
					<value title="Password">password</value>
					<value title="Number">num</value>
					<value title="Money">money</value>
					<value title="Price">price</value>
					<value title="Country code (ISO 3166-1 alpha-2)">country</value>
					<value title="Currency code (ISO 4217)">currency</value>
					<value title="Unit code (UN/CEFACT Recommendation 20)">unit</value>
					<value title="Date">date</value>
					<value title="Date and time">datetime</value>
				</attribute>
			</attributes>

			<attributes title="Single line/E-Mail/URL/Telephone/Password/Number/Money/Price/Country code/Currency code/Unit code/Date/Date and time">
				<attribute name="caption" type="string" title="Caption"/>
			</attributes>

			<attributes title="Single line/E-Mail/URL/Telephone/Password">
				<attribute name="pattern" type="string" title="Pattern"/>
			</attributes>

			<attributes title="Multiple lines/HTML">
				<attribute name="height" type="string" title="Height (CSS)"/>
			</attributes>

			<content type="string" title="Initial value"/>

			<description>TEXTBOX represents a form control for editing a data element that is displayed according to a given input type and is attached to a label.</description>
		</command>
	</namespace>

	<namespace name="debug" title="Debug">
		<command name="debug:output" title="Output to debug console">
			<content type="string" title="Value"/>

			<description>DEBUG:OUTPUT outputs a value to the debug console.</description>

			<example>
				<![CDATA[
					<debug:output>An error has occured!</debug:output>
				]]>
			</example>
		</command>

		<command name="debug:dump" title="Dump variables to debug console">
			<attributes>
				<attribute name="var" type="var" title="Variable name"/>
			</attributes>

			<description>DEBUG:DUMP dumps human-readable information about all variables or only one specific variable to the debug console. Arrays are thereby explored recursively with values indented to show structure.</description>

			<example>
				<![CDATA[
					<debug:dump/>
				]]>
			</example>
		</command>

		<command name="debug:log" title="Write to debug log">
			<content type="string" title="Message"/>

			<description>DEBUG:LOG writes a message to the debug log.</description>

			<example>
				<![CDATA[
					<debug:log>An error has occured!</debug:log>
				]]>
			</example>
		</command>

		<command name="debug:exclude" title="Exclude code">
			<content type="ixml"/>

			<description>DEBUG:EXCLUDE excludes the embedded code from execution.</description>

			<example>
				<![CDATA[
					<debug:exclude>
						<output>This will be parsed and validated but not executed!</output>
					</debug:exclude>
				]]>
			</example>
		</command>
	</namespace>
</ixmldoc>
